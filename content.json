{"meta":{"title":"WX-JIN","subtitle":"人生没有彩排，每一天都是现场直播。","description":null,"author":"WX-JIN","url":"http://yoursite.com"},"pages":[{"title":"","date":"2017-01-25T03:51:24.000Z","updated":"2016-04-20T07:44:10.000Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"&lt;!DOCTYPE HTML&gt;"},{"title":"关于我","date":"2017-04-17T15:46:41.000Z","updated":"2017-04-16T16:23:16.000Z","comments":true,"path":"aboutme/index.html","permalink":"http://yoursite.com/aboutme/index.html","excerpt":"","text":"现况: 角色： 一名Android工程师，持续学习者，在移动支撑方、创业公司扛过旗、打过仗。 坐标： 厦门 财富: 积累多年的Android项目经验，对技术开发管理、产品设计到开发过程等领域均有接触。 官职： 现任：Android研发工程师 现状： 目前已提离职，现准备另谋他家！ 博客： 私人博客，记录和分享下自己在软件开发过程所涉及的相关知识和相关技术，二月底开了CSDN博客分享些自己写的控件和一些疑难杂症的解决方案。 日常： 日常工作外，有时还会抽出时间搞搞技术相关的东西，写写东西记录记录。偶尔也会看看电影、动漫、打打球之类！ 严肃的自白： 勤于思考和反问，善于听取意见，接受指导与批评，喜欢团队奋战氛围。 热爱专研，乐于接受新的事物、新的挑战，持续学习者，不安于现状。 产品没有最好，只有更好，着力写出优雅的代码。 对开发充满热情，对工作认真负责。 校况: 毕业：福建师范大学 专业：网络工程 其他情况： 福建师范大学优秀毕业生 校三好生、校优秀学生干部、校优秀团员 国家励志奖学金、多次获得一、二、三综合以及学业奖学金 在校担任过体育委员、团委办公室主任、年级辅导员助理、系团委书记助理 把自己的一些作品大致整理下，收集和记录下 - - - -&gt;作品集 私家博客&lt;- - - - 博客 - - - -&gt;CSDN博客"},{"title":"作品集","date":"2017-04-17T15:46:42.000Z","updated":"2017-04-16T16:49:57.000Z","comments":true,"path":"collection/index.html","permalink":"http://yoursite.com/collection/index.html","excerpt":"","text":"掌通家园 （千万级用户，百万级日活） 掌通家园为宝宝精心打造的一款基于移动互联网家园共育平台，搭建一个家庭与校方互动、互助的共同教育辅助平台。 负责新版本框架搭建，MVP模式、模块化抽离、基类以及基础模块封装，使用编译时注解重构协议接口、数据埋点。集成单进程路由交互各个模块，之后拓展使用AIDL进行多进程通信、AOP进行行为统计、性能检测等。 负责账号体系项目线，主要负责涉及账号剥离、切换Https等账号相关业务。 负责IM模块重构，项目接入云通讯和环信双SDK自由切换使用，采用工厂模式解析云通讯、环信消息体，封装自定义项目IM消息体，负责封装中间层的消息发送、转发、监听等基础API接口，采用RxJava链式结构封装媒体文件上传、下载，进行七牛云和服务端交互。 负责项目全局红点、未读消息的统一管理和分发，采用单例和local广播进行消息实时更新。 重构个推消息推送，搭建基础推送、类型跳转。 查看更多和彩漫信息和应用截图 和彩漫 （安卓和IOS版本皆有） 和彩漫应用是由咪咕动漫有限公司（中国移动动漫基地）推出短彩信接管、个性贺卡合集以及贺卡在线制作的软件。 项目负责人，负责版本的扁平化改版和功能、版本更新迭代。负责团队的开发整合，对项目的架构、代码的安全性、流程性、稳定性的整合。 负责团队协作开发，负责代码review（代码规范、控件统一、内存优化等）。 使用Builder模式封装OkHttp网络请求并采用3DES进行数据加密。 拦截短彩信，自定义消息展示弹框、消息列表。 集成Glide实现图片的请求、显示和缓存。 自定义可移动、绘图等控件。 查看更多和彩漫信息和应用截图 三平寺 三平寺APP是推广、宣传一个国家4A旅游景区，给广大信仰者提供一个信息、了解景区的平台，让广大旅游爱好者、信仰者及时了解到景区的信息、查看到景区的点点滴滴！同时可以让更多人了解到景区周边的人文特色、文化风俗等。 个人开发。 多线Http断点续传功能。 MediaPlayer+绑定服务组合背景音乐播放。 爬虫中国天气网数据，获取三平寺天气情况。 使用Fresco框架实现图片的请求、显示和缓存。 查看更多三平寺信息和应用截图 2016厦门咪咕动漫次元盛典-验票扫描客户端 由咪咕动漫有限公司倾力打造的咪咕次元盛典将在厦门工人体育馆、五一文化广场举行，立足于“次元盛典 圈住好玩”的活动主旨，咪咕动漫将带来一场全方位、多元化、别具一格的动漫盛宴！ 项目负责人，负责代码review工作，把控项目的功能开发，项目进度，负责团队开发整合。 基于Google的ZXing封装实现自定义扫描。 集成Retrofit、RxJava封装网络请求。 查看更多2016厦门咪咕动漫次元盛典-验票扫描客户端信息和应用截图 咪咕动漫广告SDK（安卓和IOS版本皆有） 由咪咕动漫有限公司（中国移动动漫基地）打造的广告系统平台，提供了各种广告接入。 项目职责：移动端的负责人，负责、把控、分配、维护安卓SDK的功能开发和项目进度，负责Ios的功能开发、打包SDK和发布，目前双平台都实现了启动页、广告条、插屏，支持播放gif图和视频。 目前有部分厂家已接入完毕，例如咪咕公司产品-和彩印（Android和Ios双平台），已上线！ 查看更多咪咕动漫广告SDK信息和应用截图 拍购 拍购是一款 拍照动漫周边产品实现同款同物购物，也增加通过动画、物品等内容在APP中直接点击获取相关产品信息功能（仿趣糖功能），通过拍购，您可以追踪最潮最棒的二次元动漫，购买最热最新的动漫同款产品。 项目职责：负责人，分配把控项目的功能开发，项目进度，负责团队开发整合和自定义控件开发。 查看更多拍购信息和应用截图 头条动态 头条动态应用展示动态新网，时时更新，查看来自各个网站的新闻，让你了解最近国内外资讯，简简单单去看每一篇新闻！ 项目职责：负责人。 查看更多头条动态信息和应用截图 其他汇总 移动彩漫SDK能力（提供不同厂家）项目职责：项目负责人，负责整个项目开发，彩漫md5和base64进行加密处理，对项目进行ant快速打包、快速替换包名生成不同，提供给不同厂家使用。 彩漫插件SDK（提供给掌上公交接入）项目职责：项目负责人，负责整个SDK插件开发，负责项目获取彩漫接口信息资源，将资源做成插件化提供给第三方使用、对项目进行混淆、封装成jar提高安全性。 贵州电子贺卡项目描述：项目负责人，负责团队的开发整合，对项目的进行整合。负责项目的网络访问请求加密和软件升级封装等 其他还开发一些有：车秘书、檀阅、休闲五子棋游戏、毕设雷霆战机游戏等等"},{"title":"和彩漫","date":"2016-04-20T08:46:43.000Z","updated":"2016-04-20T14:05:52.000Z","comments":true,"path":"collection/cm/index.html","permalink":"http://yoursite.com/collection/cm/index.html","excerpt":"","text":"和彩漫安卓客户端下载地址 和彩漫苹果客户端，请打开苹果手机 appstore搜索和彩漫下载 原谅我把之前运营的推广的词拷过来：和彩漫app是一款由咪咕动漫有限公司（中国移动动漫基地）推出的个性贺卡合集以及贺卡在线制作的手机软件，海量的电子贺卡内容涉及到生活中的各个方面，适合在不同的情景来表达祝福，同时软件还有在线DIY的功能，如果你不喜欢库里面的贺卡，那么你可以自己动手来做，欢迎需要的朋友赶快来下载体验吧！和彩漫，一款深受广大用户喜欢的个性贺卡应用！节日祝福、好友问候、出游邀约、趣味分享，个性表达的超级神器! 富含海量精品图片素材，知名动漫形象、文艺插画作品、诗词经典应有尽有； 涵盖日常使用场景，送祝福、表心情、发邀约、涨知识，满足不同类型用户随时随地不同沟通需求； 功能全面，个性DIY、文字智能配图、语音输入文字、定时发送，情感表达不再枯燥无味； 咪咕彩漫贺卡，不只是祝福，不只是表达，还有精品动漫、涨知识的趣味杂志、精彩的社会热点调侃、养生保健~ 一款不只是发祝福的贺卡应用，你值得拥有~ &#160;&#160;&#160;&#160;"},{"title":"咪咕动漫广告SDK","date":"2016-04-20T12:12:12.000Z","updated":"2016-04-21T01:12:52.000Z","comments":true,"path":"collection/ad/index.html","permalink":"http://yoursite.com/collection/ad/index.html","excerpt":"","text":"目前双平台都实现了启动页、广告条、插屏，支持播放gif图和视频。目前有部分厂家已接入完毕，例如咪咕公司产品-和彩印（Android和Ios双平台），已上线！接入和彩印安卓客户端可以去手机市场下载即可，Ios版本，打开苹果手机appstore搜和彩印下载！"},{"title":"拍购","date":"2016-04-20T12:11:11.000Z","updated":"2016-04-20T14:07:02.000Z","comments":true,"path":"collection/pg/index.html","permalink":"http://yoursite.com/collection/pg/index.html","excerpt":"","text":"拍购安卓下载 拍购是一款 拍照动漫周边产品实现同款同物购物，也增加通过动画、物品等内容在APP中直接点击获取相关产品信息功能（仿趣糖功能），通过拍购，您可以追踪最潮最棒的二次元动漫，购买最热最新的动漫同款产品。"},{"title":"2016厦门咪咕动漫次元盛典-验票扫描客户端","date":"2016-04-20T12:00:00.000Z","updated":"2016-04-20T13:54:34.000Z","comments":true,"path":"collection/sc/index.html","permalink":"http://yoursite.com/collection/sc/index.html","excerpt":"","text":"2016厦门咪咕动漫次元盛典-验票扫描客户端安卓下载 和彩漫app是一款由咪咕动漫有限公司（中国移动动漫基地）推出的个性贺卡合集以及贺卡在线制作的手机软件。"},{"title":"三平寺","date":"2016-04-20T10:55:15.000Z","updated":"2016-04-20T14:01:44.000Z","comments":true,"path":"collection/sps/index.html","permalink":"http://yoursite.com/collection/sps/index.html","excerpt":"","text":"三平寺安卓APP下载地址 三平寺-国家4A旅游景区官方地址 &#160;&#160;&#160;&#160;&#160;&#160;三平寺，是闽南著名的千年古刹，地处福建省漳州市属的平和县文峰镇境内，距中国历史文化名城漳州市近五十公里，沈海复线高速公路在文峰镇文美村有个三平出入口。这里群山环抱，林海绵绵；竹涛滚滚，山清水秀，风景绮丽多姿，是人们游览、避暑的好去处，每年接待外国朋友、外籍华人、华侨、港台同胞和祖国内地的游客五六十万人。除夕之夜，三平寺更是被挤得水泄不通，他们中有善男信女，连古稀之年的老人也到此过除夕。香火颇盛，热闹非凡，别有一番景致 。 &#160; &#160; &#160; &#160;"},{"title":"动态头条","date":"2016-04-20T09:33:11.000Z","updated":"2016-04-20T13:51:22.000Z","comments":true,"path":"collection/ttdt/index.html","permalink":"http://yoursite.com/collection/ttdt/index.html","excerpt":"","text":"动态头条安卓APP下载地址 以最简单的方式展示动态新网，获取网上最新api，时时更新，查看来自各个网站的新闻，让你了解最近国内外资讯，简简单单去看每一篇新闻！"},{"title":"掌通家园","date":"2017-04-17T15:55:12.000Z","updated":"2017-04-16T17:13:27.000Z","comments":true,"path":"collection/ztjy/index.html","permalink":"http://yoursite.com/collection/ztjy/index.html","excerpt":"","text":"掌通家园安卓客户端 掌通家园苹果客户端，请打开苹果手机 appstore搜索掌通家园下载 掌通家园，见证宝宝，点滴成长掌通家园是神州鹰为幼儿园行业精心打造的一款基于移动互联网家园共育平台，致力于打造家长“超放心”的幼儿园。 &#160;&#160;&#160;&#160;&#160;&#160;"}],"posts":[{"title":"android.app.RemoteServiceException Bad notification posted from package","slug":"2016-06-08-android.app.RemoteServiceException Bad notification posted from package","date":"2016-06-08T01:08:05.000Z","updated":"2016-06-26T01:59:44.000Z","comments":true,"path":"2016/06/08/2016-06-08-android.app.RemoteServiceException Bad notification posted from package/","link":"","permalink":"http://yoursite.com/2016/06/08/2016-06-08-android.app.RemoteServiceException Bad notification posted from package/","excerpt":"android.app.RemoteServiceException: Bad notification posted from package xxx: Couldn’t expand RemoteViews for: StatusBarNotification 这点错误其实跟以下报错信息差不多！ java.lang.IllegalStateException: The content of the adapter has changed but ListView did not receive a notification. Make sure the content of your adapter is not modified from a background thread, but only from the UI thread. Make sure your adapter calls notifyDataSetChanged() when its content changes.","text":"android.app.RemoteServiceException: Bad notification posted from package xxx: Couldn’t expand RemoteViews for: StatusBarNotification 这点错误其实跟以下报错信息差不多！ java.lang.IllegalStateException: The content of the adapter has changed but ListView did not receive a notification. Make sure the content of your adapter is not modified from a background thread, but only from the UI thread. Make sure your adapter calls notifyDataSetChanged() when its content changes. 原因是：数据在其他线程更新了，但没有在主线程去notifyDataSetChanged() 解决办法是：数据更新的时候，记得在UI线程notifyDataSetChanged()！ 个人博客：http://soubw.com/CSDN博客：http://blog.csdn.net/wx_jin交流群：313870489","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"疑难杂症","slug":"疑难杂症","permalink":"http://yoursite.com/tags/疑难杂症/"},{"name":"RemoteServiceException","slug":"RemoteServiceException","permalink":"http://yoursite.com/tags/RemoteServiceException/"}]},{"title":"解决Android中onActivityResult方法不执行的办法","slug":"2016-05-24-解决Android中onActivityResult方法不执行的办法","date":"2016-05-24T11:31:35.000Z","updated":"2016-06-26T01:52:18.000Z","comments":true,"path":"2016/05/24/2016-05-24-解决Android中onActivityResult方法不执行的办法/","link":"","permalink":"http://yoursite.com/2016/05/24/2016-05-24-解决Android中onActivityResult方法不执行的办法/","excerpt":"&#160;&#160;&#160;&#160;最近在开发公司项目，在使用startActivityForResult关联俩个Activity中，发现A跳转到B，B设置setResult之后，A没有执行onActivityResult，查找一下，发现是A,B之前的启动模式都使用singleTask，查找下相关问题的解决办法。问题搞定了，下面也总结下之前自己遇到的其他情况。总结下出现问题和解决办法：","text":"&#160;&#160;&#160;&#160;最近在开发公司项目，在使用startActivityForResult关联俩个Activity中，发现A跳转到B，B设置setResult之后，A没有执行onActivityResult，查找一下，发现是A,B之前的启动模式都使用singleTask，查找下相关问题的解决办法。问题搞定了，下面也总结下之前自己遇到的其他情况。总结下出现问题和解决办法： 如果Activity 的加载启动模式(launchMode )是SingleTask或者 ，会导致onActivityResult()没有调用。修改启动模式为singleTop或者标准。原因是：设置为 launchmode=”SingleTask”，系统将在 startActivityForResult() 后直接调用 onActivityResult()。 两个activity传递数据和返回数据时，请求方的onActivityResult始终无响应，通过debug调试模式也没见调用该方法。查看了各种配置和程序代码，均未发现有错误之处。后来仔细阅读API说明，恍然大悟，原来是调用startActivityForResult的参数问题，即调用时这样：startActivityForResult(intent, 0);是第二个参数的问题，该参数必须大于0才能在返回值，并激活onActivityResult方法。API描述：@requestCode If &gt;= 0, this code will be returned in onActivityResult() when the activity exits. Fragment 的onActivityResult() 不执行。解决方法：处理方法是在与Fragment绑定的FragmentActivity中重写onActivityResult方法。返回的result先传至Fragment的FragmentActiivity。这个FragementActivity的onActivityResult函数必须调用super(requestCode,resultCode, data); 。super.onActiivtyResult会将未被处理的result消息继续传给其fragement的onActiivtyResult。如果这种方法不管用用以下这种：解决方法就是在Fragment中直接调用startActivityForResult()方法，而不是调用 getActivity().startActivityForResult()。 个人博客：http://soubw.com/CSDN博客：http://blog.csdn.net/wx_jin交流群：313870489","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"onActivityResult","slug":"onActivityResult","permalink":"http://yoursite.com/tags/onActivityResult/"},{"name":"startActivityForResult","slug":"startActivityForResult","permalink":"http://yoursite.com/tags/startActivityForResult/"}]},{"title":"Android Studio 调试出现waiting for debugger的解决办法","slug":"2016-05-23-Android Studio 调试出现waiting for debugger的解决办法","date":"2016-05-23T02:12:32.000Z","updated":"2016-06-26T01:56:08.000Z","comments":true,"path":"2016/05/23/2016-05-23-Android Studio 调试出现waiting for debugger的解决办法/","link":"","permalink":"http://yoursite.com/2016/05/23/2016-05-23-Android Studio 调试出现waiting for debugger的解决办法/","excerpt":"&#160;&#160;&#160;&#160;在Studio开发环境中，使用真机开发经常会出现waiting for debugger，卡死不动了，让人很崩溃啊，现在我就总结下几种解决方法，希望能帮到出现同样情况的朋友！ 问题出现及解决办法：","text":"&#160;&#160;&#160;&#160;在Studio开发环境中，使用真机开发经常会出现waiting for debugger，卡死不动了，让人很崩溃啊，现在我就总结下几种解决方法，希望能帮到出现同样情况的朋友！ 问题出现及解决办法： 多开Studio，导致调试器多开，可能模拟器无法辨别是谁在调试，关掉其他的Studio，剩下要debug那一个！ 在Studio中的Android Monitor 出现了多个模拟器，也是模拟器无法辨别是谁在调试，这时候需要重新启动Studio了。 在Connected Devices出现了非正常机子名字（变成一串英文和数字的设备名字），这时候需要重新拔插真机设备，如果不行，启动任务管理器关闭adb.exe 以上应该如果还没有解决，可以重启adb，步骤：cmd进入命令行，进入adb所在目录先后执行adb kill-server，adb start-server。 欢迎关注我的博客：http://soubw.comhttp://blog.csdn.net/wx_jin交流群：313870489","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"debug","slug":"debug","permalink":"http://yoursite.com/tags/debug/"},{"name":"模拟器","slug":"模拟器","permalink":"http://yoursite.com/tags/模拟器/"},{"name":"调试","slug":"调试","permalink":"http://yoursite.com/tags/调试/"}]},{"title":"Windows下react-native安装步骤以及安装时候遇到各类已填平的坑","slug":"2016-04-07-Windows下react-native安装步骤以及安装时候遇到各类已填平的坑","date":"2016-04-07T07:47:25.000Z","updated":"2016-04-18T01:27:32.000Z","comments":true,"path":"2016/04/07/2016-04-07-Windows下react-native安装步骤以及安装时候遇到各类已填平的坑/","link":"","permalink":"http://yoursite.com/2016/04/07/2016-04-07-Windows下react-native安装步骤以及安装时候遇到各类已填平的坑/","excerpt":"&#160;&#160;&#160;&#160;Facebook 在React.js Conf 2015 大会上推出了基于 JavaScript 的开源框架 React Native，本中文教程翻译自 React Native 官方文档。&#160;&#160;&#160;&#160;React Native 结合了 Web 应用和 Native 应用的优势，可以使用 JavaScript 来开发 iOS 和 Android 原生应用。在 JavaScript 中用 React 抽象操作系统原生的 UI 组件，代替 DOM 元素来渲染等。&#160;&#160;&#160;&#160;React Native 使你能够使用基于 JavaScript 和 React 一致的开发体验在本地平台上构建世界一流的应用程序体验。React Native 把重点放在所有开发人员关心的平台的开发效率上——开发者只需学习一种语言就能轻易为任何平台高效地编写代码。Facebook 在多个应用程序产品中使用了 React Native，并将继续为 React Native 投资。 准备 安装Java环境（自行google或baidu）。 安装Android SDK（自行google或baidu）。 安装node和git参考我一篇搭建博客有涉及这俩个的安装。 安装python下载路径，我按照2.7右边那个版本。为什么选择2.7,因为3.x.x不支持详情看这里","text":"&#160;&#160;&#160;&#160;Facebook 在React.js Conf 2015 大会上推出了基于 JavaScript 的开源框架 React Native，本中文教程翻译自 React Native 官方文档。&#160;&#160;&#160;&#160;React Native 结合了 Web 应用和 Native 应用的优势，可以使用 JavaScript 来开发 iOS 和 Android 原生应用。在 JavaScript 中用 React 抽象操作系统原生的 UI 组件，代替 DOM 元素来渲染等。&#160;&#160;&#160;&#160;React Native 使你能够使用基于 JavaScript 和 React 一致的开发体验在本地平台上构建世界一流的应用程序体验。React Native 把重点放在所有开发人员关心的平台的开发效率上——开发者只需学习一种语言就能轻易为任何平台高效地编写代码。Facebook 在多个应用程序产品中使用了 React Native，并将继续为 React Native 投资。 准备 安装Java环境（自行google或baidu）。 安装Android SDK（自行google或baidu）。 安装node和git参考我一篇搭建博客有涉及这俩个的安装。 安装python下载路径，我按照2.7右边那个版本。为什么选择2.7,因为3.x.x不支持详情看这里 这边需要注意下，需要配置Java和Android SDK路径到系统环境的Path这里需要注意设置环境变量ANDROID_HOME：Android SDK Manager的位置 例如：（ANDROID_HOME=&gt; D:\\Android\\sdk）设置环境变量PATH：例如：（PATH=&gt; %ANDROID_HOME%\\tools;%ANDROID_HOME%\\platform-tools）安装react-native： 打开CMD命令窗口，选择自己要放的文件目录下，使用git clone命令从github隆react-native至本地。1git clone https:github.com/facebook/react-native.git 接着进入react-native目录下的react-native-cli目录，输入命令。1npm install -g 创建react-native项目 指定到目录下执行以下命令，创建新的项目AwesomeProject。1react-native init AwesomeProject 由于被墙的原因，会比较慢，耐心等待！ 运行package 进到刚创建的AwesomeProject，执行react-native start。12cd AwesomeProjectreact-native start 此时可以通过浏览器访问 http://localhost:8081/index.android.bundle?platform=android，出现如下页面表示服务端已经可以了。cmd运行项目####一种先打开模拟器或者链接手机设备。 另外再启动一个新的命令行,到你的项目下，执行(设备允许usb调试)。1react-native run-android 成功了！ ####另一种没有开模拟器或者链接手机设备。 也是启动上面那句代码1react-native run-android 之后配置路径请看我朋友的文章https://duduzai.github.io/2016/03/23/SetupReactNativeInWindows/ 错误集合：没有连接上模拟器或者手机设备，请开模拟器或者连接上手机设备在执行react-native run-android 如果构建项目删除，但发现Windows删除不了过长的文件，这边有工具可以安装下解决win下文件目录太长无法删除的问题 123456789101112安装npm install fuckwinfsdel -g使用fuckwinfsdel youdir例fuckwinfsdel node_modules将会删除当前目录下 node_modules 文件夹。fuckwinfsdel D:\\expressgit\\node_modules将会删除D:\\expressgit\\node_modules文件夹。项目地址 https://github.com/hezedu/fuckwinfsdel 欢迎关注我的博客：http://blog.csdn.net/wx_jin交流群：313870489 参考文章：https://duduzai.github.io/2016/03/23/SetupReactNativeInWindows/http://wiki.jikexueyuan.com/project/react-native/ 私家博客：http://soubw.com/CSDN：http://blog.csdn.net/wx_jin欢迎您的关注！","categories":[{"name":"react-native","slug":"react-native","permalink":"http://yoursite.com/categories/react-native/"}],"tags":[{"name":"疑难杂症","slug":"疑难杂症","permalink":"http://yoursite.com/tags/疑难杂症/"},{"name":"Windows","slug":"Windows","permalink":"http://yoursite.com/tags/Windows/"},{"name":"安装","slug":"安装","permalink":"http://yoursite.com/tags/安装/"}]},{"title":"Android 引导使用说明、标签功能的封装库","slug":"2016-04-06-Android 引导使用说明、标签功能的封装库","date":"2016-04-06T00:11:25.000Z","updated":"2016-04-18T01:28:22.000Z","comments":true,"path":"2016/04/06/2016-04-06-Android 引导使用说明、标签功能的封装库/","link":"","permalink":"http://yoursite.com/2016/04/06/2016-04-06-Android 引导使用说明、标签功能的封装库/","excerpt":"&#160;&#160;&#160;&#160;之前公司做了一个项目，里面一个功能有关于在图片上贴标签的，现在比较有时间，把这个功能，单独抽出来做个封装成库（aar），在这基础上加了一些附件功能上去，现在就把简单介绍下：贴出之前产品的红色箭头指向就是标签效果图：","text":"&#160;&#160;&#160;&#160;之前公司做了一个项目，里面一个功能有关于在图片上贴标签的，现在比较有时间，把这个功能，单独抽出来做个封装成库（aar），在这基础上加了一些附件功能上去，现在就把简单介绍下：贴出之前产品的红色箭头指向就是标签效果图： JTags&#160;&#160;&#160;&#160;JTags 可以展示自己要标明在APP页面任何位置的标签，也可以作为新手指导来提供用户说明，之后还有还会陆续添加一些相辅的功能，希望大家多多支持！ps：如果有什么bug或者优化点也可以向博主说下，留言或者加交流群：313870489。效果图如下（gif进行压缩效果变差了）：&#160;&#160; 简要说明目前封装库支持： 新手引导功能，自动按步骤引导。 手动关闭引导。 贴标签（普通标签，焦点光晕标签，折线光晕标签三种标签）。 隐藏所有显示的标签。 显示所有隐藏的标签。 打开所有标签焦点的光晕效果。 关闭所有标签焦点的光晕效果。 支持单个标签显示、隐藏。 源码地址：https://github.com/WX-JIN/JTags 用法 Android Studio 123compile &apos;com.soubw:jtags:0.0.2&apos;//引入依赖库，具体最新aar封装库版本，请查看[github](https://github.com/WX-JIN/JTags)上的版本 &#125;); Eclipse 到GitHub，copy源码 基本用法 添加布局 1234&lt;com.soubw.jtags.JTagLayout android:id=&quot;@+id/jTagLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; 获取标签布局对象 1JTagLayout jTagLayout = (JTagLayout) findViewById(R.id.jTagLayout); 标签监听 12345jTagLayout.setOnJTagsClickListener(new OnJTagClickListener() &#123; @Override public void onJTagClick(JTag jTag) &#123; &#125;&#125;); 添加单个标签 12JTagBean bean = new JTagBean(200,300,&quot;WX_JIN&quot;, JTagType.NONE);jTagLayout.addJTag(bean); 添加多个标签 1234ArrayList&lt;JTagBean&gt; jTagBeans = new ArrayList&lt;&gt;(); jTagBeans.add(new JTagBean(120,222,&quot;WX_JIN1&quot;, JTagType.CIRCLE));jTagBeans.add(new JTagBean(60,40,&quot;WX_JIN2&quot;, JTagType.NONE));jTagBeans.add(new JTagBean(240,536,&quot;WX_JIN3&quot;, JTagType.POLYLINE));jTagLayout.addJTag(bean); 新手引导说明 123456ArrayList&lt;JTagBean&gt; jTagBeans = new ArrayList&lt;&gt;(); jTagBeans.add( new JTagBean(JTagType.BG, R.drawable.guide_bg)); //添加一张新手指导透明浮层，类型为JTagType.BG，之后添加的标签会按步骤一步一步显示出来。jTagBeans.add(new JTagBean(40,562,&quot;第一步&quot;, JTagType.CIRCLE));jTagBeans.add(new JTagBean(360,200,&quot;第二步&quot;, JTagType.NONE));jTagBeans.add(new JTagBean(140,436,&quot;关闭&quot;, JTagType.POLYLINE));jTagLayout.addJTag(bean); 其他 1234567jTag.showJTag();//显示单个标签jTag.hideJTag();//隐藏单个标签jTagLayout.showAllJTags();//显示所有标签jTagLayout.hideAllJTags();//隐藏所有标签jTagLayout.startAllAnim();//打开所有标签光晕效果jTagLayout.cancelAllAnim();//取消所有标签光晕效果jTagLayout.dismissGuide();//手动关闭剩下新手引导 JTagType标签类型 123456public enum JTagType &#123; NONE,//普通 CIRCLE,//焦点光晕效果 POLYLINE,//折线 BG,//新手引导&#125; JPolyLineType折线方位类型 123456public enum JPolyLineType &#123; LEFT_TOP,//左上 LEFT_BOTTOM,//左下 RIGHT_TOP,//右上 RIGHT_BOTTOM,//右下&#125; JTagBean标签实体对象 12345678private int jTagX;//标签焦点X位置 单位pxprivate int jTagY;//标签焦点Y位置 单位pxprivate int jTagTextColor;//标签内容颜色private int jTagTextSize;//标签内容字体大小private String jTagContent;//标签内容private int jTagBg;//标签背景图private JTagType jTagType;//标签类型private JPolyLineType jPolyLineType;//为折线类型，折线方位 以上实体对象可以根据自己需求添加、设置。 详细用法可以参考Demo 最后，再次说下如果发现问题、或者有优化地方、或或者如果有新的辅助功能可以加入，可以在我的GitHub上提issues，或者留言，博主会第一时间来处理。 谢谢！ 私家博客：http://soubw.com/CSDN：http://blog.csdn.net/wx_jin欢迎您的关注！","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"自定义开发","slug":"自定义开发","permalink":"http://yoursite.com/tags/自定义开发/"},{"name":"引导","slug":"引导","permalink":"http://yoursite.com/tags/引导/"},{"name":"标签","slug":"标签","permalink":"http://yoursite.com/tags/标签/"}]},{"title":"Github绑定自己的域名","slug":"2016-03-31-Github绑定自己的域名","date":"2016-03-31T14:55:13.000Z","updated":"2016-04-18T01:29:58.000Z","comments":true,"path":"2016/03/31/2016-03-31-Github绑定自己的域名/","link":"","permalink":"http://yoursite.com/2016/03/31/2016-03-31-Github绑定自己的域名/","excerpt":"买了两年的阿里云云服务终于到期，两年内，感觉没有怎么去使用，现在想想，先不续费了，之前在那博客也不得重新绑定ip了，现在就把重新记录下，绑定过程！想要在用自己购买的域名绑定下自己在github的博客怎么办呢？方法很简单，官方也有很详细的帮助说明地址。 前提 已购买好了域名。 搭建好了，github上的博客，可以查看我上一篇文章。Windows下使用Hexo+GithubPage搭建博客","text":"买了两年的阿里云云服务终于到期，两年内，感觉没有怎么去使用，现在想想，先不续费了，之前在那博客也不得重新绑定ip了，现在就把重新记录下，绑定过程！想要在用自己购买的域名绑定下自己在github的博客怎么办呢？方法很简单，官方也有很详细的帮助说明地址。 前提 已购买好了域名。 搭建好了，github上的博客，可以查看我上一篇文章。Windows下使用Hexo+GithubPage搭建博客 步骤 在你hexo资源（source）目录下新建CNAME无后缀文件 在文件内容中输入你购买的域名地址。eg：soubw.com 如图： 之后编译下，接着push静态代码到github上面去。 获取你github博客网站的ip地址。 打开cmd命令。ping下你博客地址。eg：ping wx-jin.github.io 就出输入这个这个博客的ip地址。 如图： 获取到你的ip地址，下一步用到。 在你购买域名的网站解析DNS 我是在新网购买了域名，我登录到新网的域名解析。 添加主机解析ip和cname（别名） 如图： 如图： 之后保存，dns差不多10分钟生效，等下10分钟刷新搞定！ 私家博客：http://soubw.com/CSDN：http://blog.csdn.net/wx_jin","categories":[{"name":"Github博客","slug":"Github博客","permalink":"http://yoursite.com/categories/Github博客/"}],"tags":[{"name":"域名","slug":"域名","permalink":"http://yoursite.com/tags/域名/"}]},{"title":"Windows下使用Hexo+GithubPage搭建博客","slug":"2016-03-31-Windows下使用Hexo+GithubPage搭建博客","date":"2016-03-31T08:33:18.000Z","updated":"2016-06-26T01:51:06.000Z","comments":true,"path":"2016/03/31/2016-03-31-Windows下使用Hexo+GithubPage搭建博客/","link":"","permalink":"http://yoursite.com/2016/03/31/2016-03-31-Windows下使用Hexo+GithubPage搭建博客/","excerpt":"前不久电脑挂了，许多东西都需要重新搞，包括这个，现在重新疏导一下，记录下在Windows下使用Hexo+GithubPage搭建博客的过程！","text":"前不久电脑挂了，许多东西都需要重新搞，包括这个，现在重新疏导一下，记录下在Windows下使用Hexo+GithubPage搭建博客的过程！ 准备工作 安装Node.js下载地址：传送门去 NodeJs 官网下载相应版本，进行安装即可。可以通过node -v的命令来测试NodeJS是否安装成功 安装Git下载地址：传送门去 Git 官网下载相应版本，进行安装即可。我选择在第二个在系统的cmd也可以使用可以通过git –version的命令来测试git是否安装成功 注册Github账号去 Github 官网进行注册即可。注册完之后记得添加 SSH Key。这个 SSH Key是一个认证，让github识别绑定这台机器，允许这台机器提交。执行如下命令：1cd ~/. ssh ~这个符号，表示在用户目录下执行代码如果提示：No such file or directory 说明你是第一次使用git。下面就说下怎么配置SSH Key。生产新的SSH Key配置在Git Bash执行代码：1ssh-keygen -t rsa -C &quot;85268837@qq.com&quot; 记得修改成你自己邮箱地址。成功后会生成两个文件id_rsa 以及id_rsa.pub。如图，添加SSH Key到github这俩个文章在刚才用户的.ssh目录下之后在github添加SSH Key,在任意界面右上角，点击你的头像，选择Settings-&gt; SSH keys-&gt;New SSH key添加成功！ 搭建博客 安装Hexo在本地新建一个Blog文件夹，文件右键，选择Git Bash。输入指令安装hexo：npm install -g hexo等安装完毕，通过输入hexo的命令来测试Hexo是否安装成功，成功如下图展示：接着初始化Hexo：hexo init hexo初始化成功会显示Start blogging with Hexo!这时在你刚才创建的Blog里面会多出一个hexo文件进入到hexo目录，输入指令npm install，安装依赖文件以及部署形成文件打开hexo目录1cd hexo 安装依赖文件 1npm install 部署形成文件 1hexo generate 最后剩下运行server跑起hexo服务1hexo server 这时提示Hexo is running at http://loalhost:4000/.接着我们打开浏览器，输入http://localhost:4000/便可看到默认的博客，如图。到这里，hexo已经安装完毕。 配置githubPage登录Github，点击”New repository”，新建一个版本库输入仓库名：你的Github名称.github.io。然后点击Create repository。 注意：这边的创建名字，一定要用的github的用户名，不然显示不出来，因为githubPage只能你的用户名。启用GitHub Page点击右边的“Setting”菜单进入设置,点击”Launch automatic page generator”进入之后点击底部的”Continue to layouts”之后选择一个随意模版，点击”Publish page”,发布github默认生成的一个静态站点试着打开自己在github的静态网址，我的http://wx-jin.github.io，你会发现，打开是你自己刚才选择静态站点模版。 将本地hexo项目托管到Github打开修改hexo目录下配置文件_config.yml。编辑最后面的deploy属性，加入代码：123type: gitrepository: git@github.com:WX-JIN/WX-JIN.github.io.gitbranch: master type使用是git。repository属性改成你的刚才创建仓库git地址。分支branch填写master。 这边说下本地网站配置文件 _config.yml 网站的配置文件，你可以在这里配置一些基本信息，这里列举部分关键配置：123456789101112131415161718192021222324252627# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Dududzai’s Blog #网站的标题subtitle: life is struggle #副标题description: life is struggle #描述author: examble #作者信息avatar: /images/avatar.png #头像，图片位置在相应主题目录下的imageslanguage: zh-Hans #中文简体email: 85268837@qq.comtimezone:# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next #配置主题，这里使用next主题stylus: compress: true #自适应布局# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git #部署环境，基于hexo+githubpage,所以这里使用git。注意：不同版本的hexo，type有可能不同，3.x以后应使用git,具体参看官方文档 repository: git@github.com:username/username.github.io.git #git仓库地址，替换成你的username即可，其他保持不变，后面会提到如何创建git仓库 branch: master 根据自己需要修改！安装hexo-deployer-git插件1cnpm install hexo-deployer-git --save 部署你本地的主题到github上代码如下，每次修改本地主题，都需要执行以下代码12345hexo cleanhexo generator #简写 hexo ghexo deploy #简写 hexo d启动本地服务，进行文章预览调试，执行如下命令hexo server #简写 hexo s 最后看下，部署到github上的效果！ 好了，以上安装Windows下使用Hexo+GithubPage搭建博客，个人觉得是最全面的安装教程，如果有帮助的话，麻烦支持下！ 私家博客：http://soubw.com/CSDN：http://blog.csdn.net/wx_jin 参考文章：http://duduzai.github.io/2016/03/22/first-hexo/http://www.v2ex.com/t/175940","categories":[{"name":"Github博客","slug":"Github博客","permalink":"http://yoursite.com/categories/Github博客/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://yoursite.com/tags/Windows/"},{"name":"GithubPage","slug":"GithubPage","permalink":"http://yoursite.com/tags/GithubPage/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://yoursite.com/tags/Nodejs/"}]},{"title":"Android studio 制作aar 使用Gradle发布项目到JCenter仓库","slug":"2016-03-29-Android studio 制作aar 使用Gradle发布项目到JCenter仓库","date":"2016-03-29T08:01:25.000Z","updated":"2016-04-18T01:30:48.000Z","comments":true,"path":"2016/03/29/2016-03-29-Android studio 制作aar 使用Gradle发布项目到JCenter仓库/","link":"","permalink":"http://yoursite.com/2016/03/29/2016-03-29-Android studio 制作aar 使用Gradle发布项目到JCenter仓库/","excerpt":"&#160;&#160;&#160;&#160;为什么发布自己项目（aar）到JCenter呢，这个答案显而易见，把自己开发功能库或者插件库制作成aar并且发布上去，这样开发者想使用项目的功能或者插件，就可以通过Android Studio自带的gradle方式来添加aar下载到开发者自己的项目里面，简单地说，简洁，方便调用。还有一方面JCenter兼容maven，Android Studio可以默认使用JCenter了。下面我通过自己发布项目Android 自定义通讯录（仿Ios反弹效果+模糊搜索+查看手机通讯录+拉伸导航条）为例子来讲解下发布项目到JCenter库所需要的步骤。","text":"&#160;&#160;&#160;&#160;为什么发布自己项目（aar）到JCenter呢，这个答案显而易见，把自己开发功能库或者插件库制作成aar并且发布上去，这样开发者想使用项目的功能或者插件，就可以通过Android Studio自带的gradle方式来添加aar下载到开发者自己的项目里面，简单地说，简洁，方便调用。还有一方面JCenter兼容maven，Android Studio可以默认使用JCenter了。下面我通过自己发布项目Android 自定义通讯录（仿Ios反弹效果+模糊搜索+查看手机通讯录+拉伸导航条）为例子来讲解下发布项目到JCenter库所需要的步骤。 Bintray账号 需要一个bintray网站的账号，需要有github帐号可以直接登，如果没有就只能注册，bintray传送门！ 新建项目，在项目中添加所需插件 这边就是我自己项目为例子，在根项目的build.gradle的添加上传到公共的JCenter仓库所需俩个插件 ` classpath ‘com.jfrog.bintray.gradle:gradle-bintray-plugin:1.0’ classpath &apos;com.github.dcendents:android-maven-gradle-plugin:1.3&apos;`，如图：![这里写图片描述](http://img.blog.csdn.net/20160329163336288) 构建module模块build.gradle信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106apply plugin: &apos;com.android.library&apos;//添加申请生成插件apply plugin: &apos;com.github.dcendents.android-maven&apos;apply plugin: &apos;com.jfrog.bintray&apos;def siteUrl = &apos;https://github.com/WX-JIN/JContact&apos; //项目在github主页地址def gitUrl = &apos;https://github.com/WX-JIN/JContact.git&apos; //Git仓库的地址group = &quot;com.soubw&quot;//发布aar前缀根节点version = &quot;0.0.1&quot;//发布aar的库版本//最后生成是compile &apos;com.soubw:jcontactlib:0.0.1&apos; 就是group + ：+module名字 + ：+versionandroid &#123; compileSdkVersion 23 buildToolsVersion &quot;23.0.2&quot; defaultConfig &#123; minSdkVersion 14 targetSdkVersion 23 versionCode 1 versionName &quot;1.0&quot; &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125; &#125;&#125;install &#123; repositories.mavenInstaller &#123; // This generates POM.xml with proper parameters pom &#123; project &#123; packaging &apos;aar&apos; name &apos;JContact&apos;//添加项目描述 url siteUrl licenses &#123; license &#123; name &apos;The Apache Software License, Version 2.0&apos; url &apos;http://www.apache.org/licenses/LICENSE-2.0.txt&apos; &#125; &#125; developers &#123; developer &#123; id &apos;wx_jin&apos;//设置自己ID name &apos;WangXiaojin&apos;//设置自己名字 email &apos;85268837@qq.com&apos;//设置自己邮箱 &#125; &#125; scm &#123; connection gitUrl developerConnection gitUrl url siteUrl &#125; &#125; &#125; &#125;&#125;task sourcesJar(type: Jar) &#123; from android.sourceSets.main.java.srcDirs classifier = &apos;sources&apos;&#125;task javadoc(type: Javadoc) &#123; source = android.sourceSets.main.java.srcDirs classpath += project.files(android.getBootClasspath().join(File.pathSeparator))&#125;task javadocJar(type: Jar, dependsOn: javadoc) &#123; classifier = &apos;javadoc&apos; from javadoc.destinationDir&#125;artifacts &#123; archives javadocJar archives sourcesJar&#125;Properties properties = new Properties()properties.load(project.rootProject.file(&apos;local.properties&apos;).newDataInputStream())bintray &#123; user = properties.getProperty(&quot;bintray.user&quot;) key = properties.getProperty(&quot;bintray.apikey&quot;) configurations = [&apos;archives&apos;] pkg &#123; repo = &quot;maven&quot; name = &quot;jcontact&quot; //项目在JCenter的名字 websiteUrl = siteUrl vcsUrl = gitUrl licenses = [&quot;Apache-2.0&quot;] publish = true &#125;&#125;dependencies &#123; compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) compile &apos;com.android.support:appcompat-v7:23.1.1&apos;&#125; 按配置，修改有中文字既可以了！ 配置自己网站的信息 我们上传到jcenter的网站Bintray，需要用户验证，一个网站用户名一个是配置清单的API KEY 这个API KEY是从网站清单获取的，在https://bintray.com/profile/edit 可以看到API KEY一栏，这边需要你再次网站密码，才能看到你API KEY 这俩个配置信息即我们上面配置bintray.user和bintray.apikey,在步骤3的时候，我们获取这个信息是从local.properties这个文件读取的，我们需要在自己项目的local.properties添加 bintray.user=你bintray的用户名 bintray.apikey=你的网站的API KEY这里为什么要写在local.properties呢，因为一般我们都是使用github上传项目到github，这时github会自动忽略local.properties这个文件上传。或者使用git（可以利用gitignore忽略这个文件到git) 执行在stuido的terminal执行gradlew install 如果提示成功接着进行上传代码gradlew bintrayUpload这边如果出错，一般编码问题，自己修改下就可以了！ 在网站上提交申请到Jcenter 当bintrayUpload成功之后，到自己网站项目提交到申请 最后差不多几小时，一般都通过申请！ 私家博客：http://soubw.com/CSDN：http://blog.csdn.net/wx_jin欢迎您的关注！ 参考文章：https://www.virag.si/2015/01/publishing-gradle-android-library-to-jcenter/","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Studio","slug":"Studio","permalink":"http://yoursite.com/tags/Studio/"},{"name":"仓库","slug":"仓库","permalink":"http://yoursite.com/tags/仓库/"},{"name":"aar","slug":"aar","permalink":"http://yoursite.com/tags/aar/"}]},{"title":"Android studio b Error No resource found that matches the given name (at 'src' with value '@dra...","slug":"2016-03-16-Android studio b Error No resource found that matches the given name (at 'src' with value '@dra...","date":"2016-03-16T03:16:12.000Z","updated":"2016-04-18T01:31:26.000Z","comments":true,"path":"2016/03/16/2016-03-16-Android studio b Error No resource found that matches the given name (at 'src' with value '@dra.../","link":"","permalink":"http://yoursite.com/2016/03/16/2016-03-16-Android studio b Error No resource found that matches the given name (at 'src' with value '@dra.../","excerpt":"问题原因问题贴出代码：123No resource found Errors for support:appcompat-v7:22.0.0或者E:\\????\\okhttp-utils-master\\sample-okhttp\\build\\intermediates\\res\\debug\\layout\\notification_media_cancel_action.xml:18: error: Error: No resource found that matches the given name (at &apos;src&apos; with value &apos;@drawable/abc_ic_clear_mtrl_alpha&apos;).","text":"问题原因问题贴出代码：123No resource found Errors for support:appcompat-v7:22.0.0或者E:\\????\\okhttp-utils-master\\sample-okhttp\\build\\intermediates\\res\\debug\\layout\\notification_media_cancel_action.xml:18: error: Error: No resource found that matches the given name (at &apos;src&apos; with value &apos;@drawable/abc_ic_clear_mtrl_alpha&apos;). &#160;&#160;&#160;&#160;一般出现这个情况有两种原因：1、项目路径包含中文字2、也会由于项目路径长度太长导致（window系统下） 解决办法关掉项目，1、把项目移到不含中文字的目录下2、把项目尽可能移到绝对路径较短下，比如直接D盘下，或者下一级里面！ 私家博客：http://soubw.com/CSDN：http://blog.csdn.net/wx_jin","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"疑难杂症","slug":"疑难杂症","permalink":"http://yoursite.com/tags/疑难杂症/"},{"name":"Error","slug":"Error","permalink":"http://yoursite.com/tags/Error/"},{"name":"Studio","slug":"Studio","permalink":"http://yoursite.com/tags/Studio/"}]},{"title":"Android studio Error:Cause:org/gradle/api/publication/maven/internal/DefaultMavenFactory","slug":"2016-03-16-Android studio ErrorCause orggradleapipublicationmaveninternalDefaultMavenFactory","date":"2016-03-16T01:58:12.000Z","updated":"2016-04-18T01:31:12.000Z","comments":true,"path":"2016/03/16/2016-03-16-Android studio ErrorCause orggradleapipublicationmaveninternalDefaultMavenFactory/","link":"","permalink":"http://yoursite.com/2016/03/16/2016-03-16-Android studio ErrorCause orggradleapipublicationmaveninternalDefaultMavenFactory/","excerpt":"问题原因&#160;&#160;&#160;&#160;当我们导入其他项目的时候，有时会出现Error:Cause: org/gradle/api/publication/maven/internal/DefaultMavenFactory这个错误，原因是Gradle版本与maven插件版本不兼容，导致了，首先先看下Gradle版本是否大于2.4,gradle的版本大于1.2.3，如果maven插件是1.2就会出现这个问题。","text":"问题原因&#160;&#160;&#160;&#160;当我们导入其他项目的时候，有时会出现Error:Cause: org/gradle/api/publication/maven/internal/DefaultMavenFactory这个错误，原因是Gradle版本与maven插件版本不兼容，导致了，首先先看下Gradle版本是否大于2.4,gradle的版本大于1.2.3，如果maven插件是1.2就会出现这个问题。 解决办法一现在只需要把maven插件版本修改下（注意1.2和1.3名字区别很大,下下面红色部分）：1.21classpath &apos;com.github.dcendents:android-maven-plugin:1.2&apos; 1.31classpath &apos;com.github.dcendents:android-maven-gradle-plugin:1.3&apos; 1.3的项目名是“android-maven-gradle-plugin”1.2的项目名是”android-maven-plugin” 解决办法二&#160;&#160;&#160;&#160;最干净、最简单的方法是把这些配置信息和相关作者信息以及签名等信息通通删除即可。 另一个相关maven的问题：Error:No such property: GROUP for class: org.gradle.api.publication.maven.internal.ant.DefaultGroovyMavenDeployer&#160;&#160;&#160;&#160;问题出现在导入其他项目（一般是开源项目）到studio软件中，原因是该项目的作者会把项目做成aar发布到maven中央仓库中，所以作者在gradle中添加了相关的maven信息，有些配置信息作者当然不会上传，导致项目在编译的时候找不到这些也会报这个错误，所以最简单的办法就是把这些有关maven和签名的信息通通删掉，就可以了。当然，你也可以在gradle.properties中添加上找不到的这些属性的值以通过编译。或者还有在根项目中的build.gradle注释掉这行代码（与maven有关）例如：//apply from: ‘./gradle-mvn-push.gradle’），重新build一下就OK了 私家博客：http://soubw.com/CSDN：http://blog.csdn.net/wx_jin","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"疑难杂症","slug":"疑难杂症","permalink":"http://yoursite.com/tags/疑难杂症/"},{"name":"Error","slug":"Error","permalink":"http://yoursite.com/tags/Error/"},{"name":"Studio","slug":"Studio","permalink":"http://yoursite.com/tags/Studio/"}]},{"title":"Android studioError:(13, 0) Gradle DSL method not found:'android()'解决方法","slug":"2016-03-15-Android studioError(13, 0) Gradle DSL method not found 'android()'解决方法","date":"2016-03-15T07:50:12.000Z","updated":"2016-04-18T01:32:02.000Z","comments":true,"path":"2016/03/15/2016-03-15-Android studioError(13, 0) Gradle DSL method not found 'android()'解决方法/","link":"","permalink":"http://yoursite.com/2016/03/15/2016-03-15-Android studioError(13, 0) Gradle DSL method not found 'android()'解决方法/","excerpt":"贴出在studio导入项目出现的错误问题。Error:(13, 0) Gradle DSL method not found: ‘android()’Possible causes:The project ‘ScanDemo’ may be using a version of the Android Gradle plug-in that does not contain the method (e.g. ‘testCompile’ was added in 1.1.0).Fix plugin version and sync projectThe project ‘ScanDemo’ may be using a version of Gradle that does not contain the method.Open Gradle wrapper fileThe build file may be missing a Gradle plugin.Apply Gradle plugin图片如下：","text":"贴出在studio导入项目出现的错误问题。Error:(13, 0) Gradle DSL method not found: ‘android()’Possible causes:The project ‘ScanDemo’ may be using a version of the Android Gradle plug-in that does not contain the method (e.g. ‘testCompile’ was added in 1.1.0).Fix plugin version and sync projectThe project ‘ScanDemo’ may be using a version of Gradle that does not contain the method.Open Gradle wrapper fileThe build file may be missing a Gradle plugin.Apply Gradle plugin图片如下： &#160;&#160;&#160;&#160;这个问题是因为，我们导入项目，studio会检查导入的项目的版本是否本地存在这个版本，如果不存在，一般会提示错误：一般解决版本去下载这个版本，可以解决！但也一种情况是studio在导入项目的时候，如果不存在版本，会在整个项目（最外层的）build.gradle加上android { compileSdkVersion 21 buildToolsVersion “21.0.0”}，也有可能导入版本不存在这边版本，你手动去修改app下对应的SDK版本，这种情况也会出现Gradle DSL method not found: ‘android()；12345678910111213buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:1.2.3&apos; &#125;&#125;android &#123; compileSdkVersion 21 buildToolsVersion &quot;21.0.0&quot;&#125; 解决方案是：删除最外层build.gradle的android { compileSdkVersion 21 buildToolsVersion “21.0.0”}重新编译就可以了，希望能帮助到您！ 私家博客：http://soubw.com/CSDN：http://blog.csdn.net/wx_jin","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"疑难杂症","slug":"疑难杂症","permalink":"http://yoursite.com/tags/疑难杂症/"},{"name":"Error","slug":"Error","permalink":"http://yoursite.com/tags/Error/"},{"name":"Studio","slug":"Studio","permalink":"http://yoursite.com/tags/Studio/"}]},{"title":"Android的Application中onCreate执行多次解决方案","slug":"2016-03-15-Android的Application中onCreate执行多次解决方案","date":"2016-03-14T17:16:13.000Z","updated":"2016-04-18T01:31:44.000Z","comments":true,"path":"2016/03/15/2016-03-15-Android的Application中onCreate执行多次解决方案/","link":"","permalink":"http://yoursite.com/2016/03/15/2016-03-15-Android的Application中onCreate执行多次解决方案/","excerpt":"&#160; &#160; &#160; &#160;一般情况下，一个应用开启一个进程，application会被执行一次，如果涉及多开进程，那情况就不同了，application就会被执行多次，下面笔者根据这问题对应用开启多进程的进行分析： android:process&#160; &#160; &#160; &#160;说到Android进程，我们就得了解android:process这个属性，这个属性有什么作用？我们就来看看：&#160; &#160; &#160; &#160;在Android的帮助文档中我们可以了解到，一般情况下一个服务没有自己独立的进程，它一般是作为一个线程运行于它所在的应用的进程中。但是也有例外，Android声明文件中的android:process属性却可以为任意组件包括应用指定进程，换句话说，通过在声明文件中设置android:process属性,我们可以让组件（例如Activity, Service等）和应用(Application)创建并运行于我们指定的进程中。","text":"&#160; &#160; &#160; &#160;一般情况下，一个应用开启一个进程，application会被执行一次，如果涉及多开进程，那情况就不同了，application就会被执行多次，下面笔者根据这问题对应用开启多进程的进行分析： android:process&#160; &#160; &#160; &#160;说到Android进程，我们就得了解android:process这个属性，这个属性有什么作用？我们就来看看：&#160; &#160; &#160; &#160;在Android的帮助文档中我们可以了解到，一般情况下一个服务没有自己独立的进程，它一般是作为一个线程运行于它所在的应用的进程中。但是也有例外，Android声明文件中的android:process属性却可以为任意组件包括应用指定进程，换句话说，通过在声明文件中设置android:process属性,我们可以让组件（例如Activity, Service等）和应用(Application)创建并运行于我们指定的进程中。举个例子：12345&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.soubw.prodemo&quot; &gt;//包名&lt;activity android:name=&quot;.LoginActivity&quot; android:process=&quot;:login&quot;/&gt;//为activity开启一个进程 上面就是为登录的Activity开启一个叫login进程，只不过这个进程是在以应用默认的包名下开启的进程，叫com.soubw.prodemo:login，在属性中值为什么以冒号开头呢，因为’:’这个前缀将把这个名字附加到你的包所运行的标准进程名字的后面作为新的进程名称（只不过这个login进程为该应用私用，其他应用不能共享），上面的例子很好的讲述这点。 &#160; &#160; &#160; &#160;还有一种是不以冒号开头而以小写字母开头，我们也举个例子来说明：12&lt;activity android:name=&quot;.RegisterActivity&quot; android:process=&quot;com.wxj.register&quot;/&gt;//为activity开启一个不同于应用包名的进程 这个进程将以com.wxj.register这个名字命名的运行于全局的进程中（该进程就可以让不同应用中的各种组件可以共享一个进程）。 解决多进程次执行多次onCreate()如果应用中采用多进程方式，oncreate方法会执行多次，根据不同的进程名字进行不同的初始化。应用判断进程名字进行单独初始化，这要就可以利用进程名根据具体需求，应该加载哪些资源，执行哪些具体逻辑了。 123456789101112131415161718192021222324252627282930313233@Overridepublic void onCreate() &#123; super.onCreate(); String processName = getProcessName(this); if (processName!= null) &#123; if(processName.equals(&quot;com.soubw.prodemo&quot;))&#123; //初始化com.soubw.prodemo以包名为进程名，项目默认的进程 &#125; else if(processName.equals(&quot;com.soubw.prodemo:login&quot;))&#123; //初始化com.soubw.prodemo:login &#125;else if(processName.equals(&quot;com.wxj.register&quot;))&#123; //初始化com.wxj.register &#125;else&#123; &#125; &#125;&#125;private String getProcessName(Context context) &#123; ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE); List&lt;ActivityManager.RunningAppProcessInfo&gt; runningApps = am.getRunningAppProcesses(); if (runningApps == null) &#123; return null; &#125; for (ActivityManager.RunningAppProcessInfo proInfo : runningApps) &#123; if (proInfo.pid == android.os.Process.myPid()) &#123; if (proInfo.processName != null) &#123; return proInfo.processName; &#125; &#125; &#125; return null;&#125; 私家博客：http://soubw.com/CSDN：http://blog.csdn.net/wx_jin 参考文章地址","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"疑难杂症","slug":"疑难杂症","permalink":"http://yoursite.com/tags/疑难杂症/"},{"name":"进程","slug":"进程","permalink":"http://yoursite.com/tags/进程/"}]},{"title":"Android Studio jar冲突 文件冲突 aar引用相同的文件 引用相同的jar包 重复导入相同依赖包","slug":"2016-03-11-Android studio jar冲突 文件冲突 aar引用相同的文件 引用相同的jar包 重复导入相同依赖包","date":"2016-03-11T05:52:14.000Z","updated":"2016-04-18T01:32:12.000Z","comments":true,"path":"2016/03/11/2016-03-11-Android studio jar冲突 文件冲突 aar引用相同的文件 引用相同的jar包 重复导入相同依赖包/","link":"","permalink":"http://yoursite.com/2016/03/11/2016-03-11-Android studio jar冲突 文件冲突 aar引用相同的文件 引用相同的jar包 重复导入相同依赖包/","excerpt":"&#160; &#160; &#160; &#160;开发项目，多多少少都会引进一些第三方jar或者aar资源文件，方便开发个性化功能，但这样就经常会出现包冲突、文件冲突、重复导入资源或者导入俩个不同的包中包含有相同的文件资源呢！后果导致编译失败，提示错误！下面就来加讲解下我遇到问题及解决方法：","text":"&#160; &#160; &#160; &#160;开发项目，多多少少都会引进一些第三方jar或者aar资源文件，方便开发个性化功能，但这样就经常会出现包冲突、文件冲突、重复导入资源或者导入俩个不同的包中包含有相同的文件资源呢！后果导致编译失败，提示错误！下面就来加讲解下我遇到问题及解决方法： 1. 文件冲突文件错误提示&#160; &#160; &#160; &#160;一般类似这样的Error:Execution failed for task ‘:app:transformResourcesWithMergeJavaResForDebug’.&gt; com.android.build.api.transform.TransformException: com.android.builder.packaging.DuplicateFileException: Duplicate files copied in APK META-INF/maven/com.squareup.okio/okio/pom.xml File1: C:\\Users\\WX_JIN.gradle\\caches\\modules-2\\files-2.1\\com.squareup.okio\\okio\\1.6.0\\98476622f10715998eacf9240d6b479f12c66143\\okio-1.6.0.jar File2: D:\\Android\\workspace\\wxj\\YK\\app\\build\\intermediates\\exploded-aar\\YK\\umenglibrary\\unspecified\\jars\\classes.jar上面提示Duplicate files copied in APK META-INF/maven/com.squareup.okio/okio/pom.xml重复这个文件，我们只要去掉一个或者忽略一个就行了 解决方案&#160; &#160; &#160; &#160;在主项目中添加build-&gt;android-&gt;添加packagingOptions exclude 包含重复的文件 2. jar冲突冲突提示 解决方案使用上面这种忽略掉重复的依赖包 私家博客：http://soubw.com/CSDN：http://blog.csdn.net/wx_jin","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"冲突","slug":"冲突","permalink":"http://yoursite.com/tags/冲突/"},{"name":"Error","slug":"Error","permalink":"http://yoursite.com/tags/Error/"},{"name":"Studio","slug":"Studio","permalink":"http://yoursite.com/tags/Studio/"}]},{"title":"Android 自定义通讯录（仿Ios反弹效果+模糊搜索+查看手机通讯录+拉伸导航条）","slug":"2016-03-10-Android 自定义通讯录（仿Ios反弹效果+模糊搜索+查看手机通讯录+拉伸导航条）","date":"2016-03-10T01:31:13.000Z","updated":"2016-04-18T01:32:38.000Z","comments":true,"path":"2016/03/10/2016-03-10-Android 自定义通讯录（仿Ios反弹效果+模糊搜索+查看手机通讯录+拉伸导航条）/","link":"","permalink":"http://yoursite.com/2016/03/10/2016-03-10-Android 自定义通讯录（仿Ios反弹效果+模糊搜索+查看手机通讯录+拉伸导航条）/","excerpt":"&#160; &#160; &#160; &#160;现在很多手机APP都用到通讯录功能，在通讯录的基础上添加好友，查找好友，获取哪些好友和自己在玩同一款APP，这就需要去获取手机通讯好友信息，并把这些信息展示出来！这些就需要列表展示通讯录好友。但发现Android手机的通讯录效果比Ios效果差很多，自己决定仿照Ios效果开发个自定义的通讯录功能来。&#160; &#160; &#160; &#160;结合之前自己做过的通讯录功能以及自定义listview反弹效果和自定义搜索框。仿照一个比较全功能的通讯录来，现在把自己成品贴出来，分享下，另外这个项目会在github不断更新和完善！ github地址：https://github.com/WX-JIN/JContact","text":"&#160; &#160; &#160; &#160;现在很多手机APP都用到通讯录功能，在通讯录的基础上添加好友，查找好友，获取哪些好友和自己在玩同一款APP，这就需要去获取手机通讯好友信息，并把这些信息展示出来！这些就需要列表展示通讯录好友。但发现Android手机的通讯录效果比Ios效果差很多，自己决定仿照Ios效果开发个自定义的通讯录功能来。&#160; &#160; &#160; &#160;结合之前自己做过的通讯录功能以及自定义listview反弹效果和自定义搜索框。仿照一个比较全功能的通讯录来，现在把自己成品贴出来，分享下，另外这个项目会在github不断更新和完善！ github地址：https://github.com/WX-JIN/JContact 贴出效果图：自定义控件涉及有： 自定义ListView 自定义EditText 自定义触压显示字母View JListView反弹效果无非就是在ListView的头部加上个布局和脚部加上个布局，之后再重写onTounchEvent方法，判断tounch事件，做个逻辑处理。onTounchEvent代码如下： 123456789101112131415161718case MotionEvent.ACTION_DOWN://触摸按下 mLastY = ev.getRawY();//触摸点相对于屏幕的Y坐标,记录在mLastY break;case MotionEvent.ACTION_MOVE://触摸移动 final float deltaY = ev.getRawY() - mLastY;//用正负值判断移动方向 mLastY = ev.getRawY(); if (getFirstVisiblePosition() == 0 &amp;&amp; deltaY &gt; 0) &#123;//向下拉取，更新头部高度 updateHeaderHeight(deltaY / OFFSET_RADIO); &#125; else if (getLastVisiblePosition() == mTotalItemCount - 1 &amp;&amp; deltaY &lt; 0) &#123;//向上拉去，更新尾部高度 updateFooterHeight(-deltaY / OFFSET_RADIO); &#125; break;case MotionEvent.ACTION_UP://触摸抬起 if (getFirstVisiblePosition() == 0) &#123; resetHeaderHeight();//重置 &#125; else if (getLastVisiblePosition() == mTotalItemCount - 1) &#123; resetFooterHeight();//重置 &#125; 这里面是更新头部、脚部高度代码原理就是获取头部、脚部布局高度，在上下拉的力度进行重新设置布局高度。这里面我就贴出头部代码： 1234567private void setVisibleHeaderHeight(int height) &#123;//设置头部显示的高度 if (height &lt; 0) height = 0; LayoutParams lp = (LayoutParams) headerLayout.getLayoutParams(); lp.height = height; headerLayout.setLayoutParams(lp);&#125; 自定义ListView还涉及一个字母导航条，原理就是把导航条的视图添加到ListView来，重写onMeasure获取子控件的宽高并记录，重写onLayout画出导航条的位置。 JClearEditText自定义搜索框，附加删除按钮，跟其他自定义控件一样新建构造函数，不过在这里需要提的一点是在构造函数中需要设置AttributeSet为edittextsytle。1234public JClearEditText(Context context, AttributeSet attrs) &#123; // 这里构造方法也很重要，不加自定义EditText的很多属性就失效了 this(context, attrs, android.R.attr.editTextStyle);&#125; 之后，设置关闭按钮和搜索小图标，这个图片都是通过读取getResources()资源获取Drawable对象，通过setCompoundDrawables和setBounds结合设置图片（Edittext继承TextView包含这两种方法）。其他监听事件和隐藏图片这些就不在这里说了，有兴趣可以查看源码。 JIndexBarView导航条原理就是把字母逐个画出来，通过重写onDraw： 12345678910111213141516@Overrideprotected void onDraw(Canvas canvas) &#123; if (mListSections != null &amp;&amp; mListSections.size() &gt; 1) &#123; float sectionHeight = (getMeasuredHeight()*mListSections.size()/26)/ mListSections.size(); float paddingTop = (sectionHeight - (mIndexPaint.descent() - mIndexPaint.ascent())) / 2; for (int i = 0; i &lt; mListSections.size(); i++) &#123; float paddingLeft = (getMeasuredWidth() - mIndexPaint.measureText(getSectionText(mListSections.get(i)))) / 2; canvas.drawText(getSectionText(mListSections.get(i)), paddingLeft, mJIndexBarMargin + (sectionHeight * i) + paddingTop + mIndexPaint.descent(), mIndexPaint); &#125; &#125; super.onDraw(canvas);&#125; 之后在加个是JAdapter适配器，并且读取手机通讯录信息，把信息结合下，就可以实现了！ 目前项目已做成aar，方便开发者调用用法 Android Studio 引入依赖，依赖包最新版本请查看项目在github说明 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 compile &apos;com.soubw:jcontactlib:0.1.2&apos; ``` ## 调用示例### 添加继承实体对象JContacts（可直接使用JContacts实体对象，根据自己是否需要扩展实体属性） 实例为添加自己拓展实体属性```javapublic class MainBean extends JContacts implements Serializable &#123; private String wxj; public String getWxj() &#123; return wxj; &#125; public void setWxj(String wxj) &#123; this.wxj = wxj; &#125; public MainBean()&#123; super(); &#125;&#125;``` ### 添加继承JAdapter```javapublic class MainAdapter extends JAdapter &#123; public MainAdapter(Context context, List&lt;MainBean&gt; jContactsList, JListView lvList, int indexBarViewId, int previewViewId, int itemLayoutId, int sectionLayoutId, View loadingView) &#123; super(context, jContactsList, lvList, indexBarViewId, previewViewId, itemLayoutId, sectionLayoutId, loadingView); &#125; @Override public void convert(JViewHolder holder, JContacts bean, int type) &#123; MainBean b = (MainBean) bean; switch (type) &#123; case TYPE_ITEM: holder.setText(R.id.row_title,bean.getjName()+b.getWxj()); break; case TYPE_SECTION: holder.setText(R.id.row_title,bean.getjFirstWord()); break; &#125; &#125;&#125; 调用 mAdaptor = new MainAdapter(this, jContactsList,//联系人列表 (JListView) findViewById(R.id.lvList),//JListView对象 R.layout.jcontact_index_bar_view,//导航条视图 R.layout.jcontact_preview_view,//预览字母背景图 R.layout.jcontact_row_view,//列表内容view R.layout.jcontact_section_row_view,//列表字母view mLoadingView//加载LoadingView ); 0.1.0版本以后新增可自己选择搜索框的背景框和图标，以及提示文字&lt;com.soubw.jcontactlib.JListView android:id=\"@+id/lvList\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:dividerHeight=\"0.1dp\" android:divider=\"@android:color/black\" jcontact:jClearEditTextBg=\"@drawable/jclearedittext_bg\" jcontact:jClearEditTextCloseBg=\"@drawable/jclearedittext_close_bg\" jcontact:jClearEditTextIconBg=\"@drawable/jclearedittext_icon_bg\" jcontact:jClearEditTextNotice=\"请输入关键字\" android:scrollbars=\"none\"/&gt; 详细可以参考Demo 具体详细信息可以查看下源码：https://github.com/WX-JIN/JContact如发现问题、或者其他建议，可以在我的GitHub上提issues，或者博客留言，博主会第一时间来处理。谢谢！ 私家博客：http://soubw.com/CSDN：http://blog.csdn.net/wx_jin 参考文章地址：https://github.com/bhavyahmehta/ListviewFilter","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"自定义开发","slug":"自定义开发","permalink":"http://yoursite.com/tags/自定义开发/"},{"name":"通讯录","slug":"通讯录","permalink":"http://yoursite.com/tags/通讯录/"},{"name":"Ios","slug":"Ios","permalink":"http://yoursite.com/tags/Ios/"},{"name":"搜索","slug":"搜索","permalink":"http://yoursite.com/tags/搜索/"}]},{"title":"Android Studio出现Error:Plugin is too old, please update to a more recent version, or set ANDROID_DAIL","slug":"2016-02-25-Android studio出现ErrorPlugin is too old, please update to a more recent version, or set ANDROID_DAIL","date":"2016-02-25T01:31:13.000Z","updated":"2016-04-18T01:33:02.000Z","comments":true,"path":"2016/02/25/2016-02-25-Android studio出现ErrorPlugin is too old, please update to a more recent version, or set ANDROID_DAIL/","link":"","permalink":"http://yoursite.com/2016/02/25/2016-02-25-Android studio出现ErrorPlugin is too old, please update to a more recent version, or set ANDROID_DAIL/","excerpt":"之前发现在Android studio 2.0 Preview开发版本下出现以下问题，今天又重新出现问题，现在把问题解决方法写出来。12Error:Plugin is too old, please update to a more recent version, or set ANDROID_DAILY_OVERRIDE environment variable to &quot;1e53885d2c27df31624f87ca803a82ea4fe53b81&quot;&lt;a href=&quot;fixGradleElements&quot;&gt;Fix plugin version and sync project&lt;/a&gt; 贴下出错截图","text":"之前发现在Android studio 2.0 Preview开发版本下出现以下问题，今天又重新出现问题，现在把问题解决方法写出来。12Error:Plugin is too old, please update to a more recent version, or set ANDROID_DAILY_OVERRIDE environment variable to &quot;1e53885d2c27df31624f87ca803a82ea4fe53b81&quot;&lt;a href=&quot;fixGradleElements&quot;&gt;Fix plugin version and sync project&lt;/a&gt; 贴下出错截图奇怪了，之前开发很久都没有问题，后来不知不觉就出现这个问题。报错提示是Android plugin version 太旧了，去更新一个新的版本，但我看下这个版本是最新的，怎么还会出现这个问题呢，后来发现是Android plugin version的gradle 2.0.0-alpha1太超前了，存在bug导致了，之后我把Android plugin version的gradle改成1.2.3重新编译，问题解决了！太赞了！问题解决方法：第一种：在项目的build.gradle文件中修改classpath ‘com.android.tools.build:gradle:2.0.0-alpha1’换成classpath ‘com.android.tools.build:gradle:1.2.3’重新编译第二种：在项目结构 Project structure中修改Project-&gt;Android plugin version中把2.0.0-alpha1换成1.2.3点ok 其实两种修改都是同一个地方，只不过一个直接修改代码，一个是用界面修改。 私家博客：http://soubw.com/CSDN：http://blog.csdn.net/wx_jin","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Error","slug":"Error","permalink":"http://yoursite.com/tags/Error/"},{"name":"Studio","slug":"Studio","permalink":"http://yoursite.com/tags/Studio/"}]},{"title":"浅学使用Android的mvp模式+otto消息总线","slug":"2016-02-23-浅学使用Android的mvp模式+otto消息总线","date":"2016-02-23T01:31:13.000Z","updated":"2016-04-18T01:33:08.000Z","comments":true,"path":"2016/02/23/2016-02-23-浅学使用Android的mvp模式+otto消息总线/","link":"","permalink":"http://yoursite.com/2016/02/23/2016-02-23-浅学使用Android的mvp模式+otto消息总线/","excerpt":"对于mvp模式，越来越受到android开发者的关注，前段时间通过朋友知道的他们公司产品使用了mvp+otto模式重构项目，反馈效果不错，借此也自己去结合下，感觉有利有弊，具体的选择，可能要根据产品的应用场景和技术人员的模式定向吧！","text":"对于mvp模式，越来越受到android开发者的关注，前段时间通过朋友知道的他们公司产品使用了mvp+otto模式重构项目，反馈效果不错，借此也自己去结合下，感觉有利有弊，具体的选择，可能要根据产品的应用场景和技术人员的模式定向吧！ 先看下效果图吧：项目结构目录otto：图中的BusManage通过定一个获取bus对象，建立单例模式，节约内存消耗，也方便之后调用。 12345678910111213public class BusManager extends Bus &#123; private static class InterInstance&#123; private static final BusManager instance = new BusManager(); &#125; private BusManager()&#123; &#125; public static BusManager getInstance()&#123; return InterInstance.instance; &#125;&#125; 以上通过创建静态内部类来实现单例，具体好处是，这种方式并未加锁，因为第一次加载BusManager类时，并不会实例化单例对象，只有第一次调用getInstance()方法时会导致虚拟机加载InterInstance类，这种方式不仅能保证对象的单一性，还避免加锁带来的性能问题，又启动了延迟加载的优化。MainBean：实体类 12345678910111213141516171819202122public class MainBean &#123; private String name; private String phone; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPhone() &#123; return phone; &#125; public void setPhone(String phone) &#123; this.phone = phone; &#125;&#125; MainBean用于封装数据的实体类View：图中IMainView和MainActivityView相对应于Activity，我们通过创建一个View的接口跟presenter进行交互，降低耦合，View通过实现这个接口去绘制视图，与用户交互。 12345678910public interface IMainView &#123; void showLoading(); void hideLoading(); void showError(); void showResult(MainBean bean);&#125; 视图接口提供四个接口方法：显示加载视图、隐藏加载视图、显示加载失败视图、显示成功数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class MainActivity extends AppCompatActivity implements IMainView &#123; private RelativeLayout rlLoading; private RelativeLayout rlError; private android.widget.TextView tvResult; MainPresenter mainPresenter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); this.tvResult = (TextView) findViewById(R.id.tvResult); this.rlError = (RelativeLayout) findViewById(R.id.rlError); this.rlLoading = (RelativeLayout) findViewById(R.id.rlLoading); mainPresenter = new MainPresenter(this); mainPresenter.loadData(); rlError.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mainPresenter.clickError(); &#125; &#125;); &#125; @Override public void showLoading() &#123; rlLoading.setVisibility(View.VISIBLE); rlError.setVisibility(View.INVISIBLE); &#125; @Override public void hideLoading() &#123; rlLoading.setVisibility(View.INVISIBLE); &#125; @Override public void showError() &#123; hideLoading(); rlError.setVisibility(View.VISIBLE); &#125; @Override public void showResult(MainBean bean) &#123; tvResult.setText(bean.getName()+bean.getPhone()); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); mainPresenter.unRegister(); &#125;&#125; 通过实现View接口，去完成用户交互需求。通过创建Presenter对象去处理view和model之间关系。Model：图中IMainModel和MainModel我们也需要创建一个抽象接口（IMainModel）来降低耦合，也利于单元测试，model通过实现接口来处理数据。 123456public interface IMainModel &#123; void loadMainData(); void clickError();&#125; model的接口。提供加载数据和重新点击加载失败页面处理方法123456789101112131415161718192021222324252627282930313233343536373839404142public class MainModel implements IMainModel &#123; @Override @Produce public synchronized void loadMainData() &#123;//模拟加载数据 new AsyncTask&lt;String,String,String&gt;()&#123; @Override protected String doInBackground(String... params) &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return null; &#125; @Override protected void onPostExecute(String s) &#123; super.onPostExecute(s); MainBean bean = new MainBean(); bean.setName(&quot;WX_JIN&quot;); bean.setPhone(&quot;交流群：313870489&quot;); if ((Math.random()*2) &gt;1.5)&#123;//模拟加载数据成功或者失败 BusManager.getInstance().post(&quot;获取数据失败&quot;); &#125;else&#123; BusManager.getInstance().post(bean); &#125; &#125; &#125;.execute(); &#125; @Override public void clickError() &#123; loadMainData(); &#125;&#125; model实现类，处理加载数据。这边就是通过otto消息总线去分发加载数据后处理结果。Presenter：图中MainPresenter中间枢纽Presenter，作为model和view之间的交互。 12345678910111213141516171819202122232425262728293031323334353637public class MainPresenter &#123; private IMainView mainView; private IMainModel mainModel; public MainPresenter(IMainView mainView)&#123; this.mainView = mainView; this.mainModel = new MainModel(); BusManager.getInstance().register(this); &#125; //加载数据 public void loadData()&#123; mainView.showLoading(); mainModel.loadMainData(); &#125; public void clickError()&#123; mainView.showLoading(); mainModel.clickError(); &#125; public void unRegister()&#123; BusManager.getInstance().unregister(this); &#125; @Subscribe //成功返回数据 public void getSuccessData(MainBean bean)&#123; mainView.hideLoading(); mainView.showResult(bean); &#125; @Subscribe //失败返回 public void getError(String error)&#123; mainView.showError(); &#125;&#125; Presenter通过去实例化model接口和获取实例化的view接口去处理两者之前的数据。Presenter这边使用otto获取到Model处理完数据之后，再通过View的抽象接口更新View显示的信息。这样就实现了完整的解耦UI与逻辑操作。 如果UI有涉及ListView的Adapter，这样就要在View和Presenter中多出一个Adapter，通过这个Adapter来操作Model和View，Adapter需要实现View接口，这要就保证与Presenter之间的关联不变，扩展性也比较强，也有更好的灵活性。 以上就是自己尝试用mvp和otto一起使用，总结和记录下自己过程中的经验，其中肯定有许多不足，希望日后慢慢补充和修复。 项目源码下载路径 私家博客：http://soubw.com/CSDN：http://blog.csdn.net/wx_jin","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"开发模式","slug":"开发模式","permalink":"http://yoursite.com/tags/开发模式/"},{"name":"mvp","slug":"mvp","permalink":"http://yoursite.com/tags/mvp/"},{"name":"otto","slug":"otto","permalink":"http://yoursite.com/tags/otto/"},{"name":"框架","slug":"框架","permalink":"http://yoursite.com/tags/框架/"}]},{"title":"IOS关于证书显示：此证书的签发者无效","slug":"2016-02-16-IOS关于证书显示：此证书的签发者无效","date":"2016-02-16T01:31:13.000Z","updated":"2016-04-18T01:33:24.000Z","comments":true,"path":"2016/02/16/2016-02-16-IOS关于证书显示：此证书的签发者无效/","link":"","permalink":"http://yoursite.com/2016/02/16/2016-02-16-IOS关于证书显示：此证书的签发者无效/","excerpt":"今天（2016年2月16日）早上在编译项目后，发现要生成ipa时候出现问题，经发现是过期的‘WWDR Certificate‘，签发者Apple Worldwide Developer Relations Certification Authority到期时间为2016年2月14期。到此就知道问题所在。","text":"今天（2016年2月16日）早上在编译项目后，发现要生成ipa时候出现问题，经发现是过期的‘WWDR Certificate‘，签发者Apple Worldwide Developer Relations Certification Authority到期时间为2016年2月14期。到此就知道问题所在。 解决办法：参考官方（https://developer.apple.com/support/certificates/expiration/index.html），重新下载个新的（https://developer.apple.com/certificationauthority/AppleWWDRCA.cer），重新安装，在钥匙串访问里面－&gt;系统－&gt;证书中过期的WWDR给删除掉就可以了，到此你会发现之前的失效都变成有效了！ 附件钥匙串的图片：这个成功改变完 私家博客：http://soubw.com/CSDN：http://blog.csdn.net/wx_jin","categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"}],"tags":[{"name":"证书","slug":"证书","permalink":"http://yoursite.com/tags/证书/"},{"name":"签发者无效","slug":"签发者无效","permalink":"http://yoursite.com/tags/签发者无效/"}]},{"title":"IOS使用Launch Screen.storyboard制作广告启动界面","slug":"2016-02-01-IOS使用Launch Screen.storyboard制作广告启动界面","date":"2016-02-01T01:55:13.000Z","updated":"2016-04-18T01:33:36.000Z","comments":true,"path":"2016/02/01/2016-02-01-IOS使用Launch Screen.storyboard制作广告启动界面/","link":"","permalink":"http://yoursite.com/2016/02/01/2016-02-01-IOS使用Launch Screen.storyboard制作广告启动界面/","excerpt":"最近项目在做的广告sdk，刚好自己需要去了解这个实现启动图加载广告这个功能，大家应该都了解，之前Xcode 6是LaunchScreen.xib来当作启动视图，不过到了Xcode 7就变成了Launch Screen.storyboard，其实这两个没有多大的区别，以下我就采用Xcode 7提供的LaunchScreen.storyboard 来实现这个功能，现在把自己经验和代码分享出来。 主要思路 获取Launch Screen.storyboard 通过使用storyborardID去获取启动视图viewcontroller 获取启动viewController的视图view 之后把视图view添加到window中 最后就是新建一个图片贴在视图view中 做个定时触发处理","text":"最近项目在做的广告sdk，刚好自己需要去了解这个实现启动图加载广告这个功能，大家应该都了解，之前Xcode 6是LaunchScreen.xib来当作启动视图，不过到了Xcode 7就变成了Launch Screen.storyboard，其实这两个没有多大的区别，以下我就采用Xcode 7提供的LaunchScreen.storyboard 来实现这个功能，现在把自己经验和代码分享出来。 主要思路 获取Launch Screen.storyboard 通过使用storyborardID去获取启动视图viewcontroller 获取启动viewController的视图view 之后把视图view添加到window中 最后就是新建一个图片贴在视图view中 做个定时触发处理 废话不多说啦，直接贴代码出来： 123456789101112131415161718192021222324252627282930313233AppDelegate.m中的代码//获取LaunchScreen.storyboradUIStoryboard *storyboard = [UIStoryboard storyboardWithName:@&quot;Launch Screen&quot; bundle:nil];//通过使用storyborardID去获取启动页viewcontrollerUIViewController *viewController = [storyboard instantiateViewControllerWithIdentifier:@&quot;LaunchScreen&quot;];//获取viewController的视图self.view = viewController.view;//把视图添加到window[self.window addSubview:self.view];self.launchView = [[UIImageView alloc] initWithFrame:self.window.frame];[self.launchView setImage:[UIImage imageNamed:@&quot;launch.jpg&quot;]];//这边图片可以做网络请求加载图片、视频动画或者其他自定义的引导页[self.view addSubview:self.launchView];//将图片视图推送到前面[self.window bringSubviewToFront:self.launchView]; //设置3秒定时触发[NSTimer scheduledTimerWithTimeInterval:3 target:self selector:@selector(colseLaunchScreen) userInfo:nil repeats:NO];- (void)colseLaunchScreen &#123; if (self.launchView) &#123; [self.launchView removeFromSuperview]; self.launchView = nil; &#125; if (self.view) &#123; [self.view removeFromSuperview]; self.view = nil; &#125; &#125; 这边也可以结合LaunchImage使用,方式也是差不多，这边就不多讲了 注意有个坑已填平了：之前我用的xcode项目中General中Main Interface 启动项目初始化的主界面storyboard，用以上方法一直看不到加载的广告，后面使用在AppDelegate代码方式去加载storyboard,就可以加载出来了，目前不清楚这个是什么问题，待研究发现，如有发现朋友，方便留言告知下，谢啦（后面经过友友们的指出，发现如果不是用代码加载storyboard，那General-&gt;Main Interface-&gt;的main.storyboard加载会新建window，跟你之前传入的window不是同一个，这个之前的就被覆盖了，导致看不到广告效果，之后我修改了方案，把window改成用window中viewController中view这要就避免代码加载stroyboard了） 这里注意一下，上面这个使用storyboard启动适用ios8.0以上，但现在应用差不多都是ios7.0起，开发者为了方便适配，大多都采用launchImage启动，这种也可以使用storyboard去获取广告，完全没有问题，但在加载初始化广告肯定会消耗一点点时间这要就会出现短暂storyboard的默认页面，这个可以通过把获取rootview先隐藏，等加载完毕广告再显示出来！这要问题解决了！ 如果先获取launchImage的图片可以采用Cherpak Evgeny 分享在stackflow上的一个直接读取NSBundle中的设置 即可获取当前适用的LaunchImage的办法，代码我也贴出来： 12345678910111213141516171819202122CGSize viewSize =self.window.bounds.size;NSString *viewOrientation =@&quot;Portrait&quot;;//横屏请设置成 @&quot;Landscape&quot;NSString *launchImage =nil;NSArray *imagesDict = [[[NSBundle mainBundle] infoDictionary] valueForKey:@&quot;UILaunchImages&quot;];for(NSDictionary* dict in imagesDict) &#123; CGSize imageSize =CGSizeFromString(dict[@&quot;UILaunchImageSize&quot;]); if(CGSizeEqualToSize(imageSize, viewSize) &amp;&amp; [viewOrientation isEqualToString:dict[@&quot;UILaunchImageOrientation&quot;]]) &#123; launchImage = dict[@&quot;UILaunchImageName&quot;]; &#125;&#125;UIImageView *launchView = [[UIImageView alloc] initWithImage:[UIImageimageNamed:launchImage]];launchView.frame=self.window.bounds;launchView.contentMode=UIViewContentModeScaleAspectFill;[self.window addSubview:launchView];[UIView animateWithDuration:2.0f delay:0.0f options:UIViewAnimationOptionBeginFromCurrentState animations:^&#123; launchView.alpha=0.0f; launchView.layer.transform=CATransform3DScale(CATransform3DIdentity,1.2,1.2,1); &#125; completion:^(BOOL finished) &#123; [launchView removeFromSuperview]; &#125;]; 以上如果有错误之处或者需要指导帮忙，可以到我博客留言私家博客：http://soubw.com/CSDN：http://blog.csdn.net/wx_jin 广告demo下载地址：http://download.csdn.net/detail/wx_jin/9460717","categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"}],"tags":[{"name":"广告","slug":"广告","permalink":"http://yoursite.com/tags/广告/"},{"name":"storyboard","slug":"storyboard","permalink":"http://yoursite.com/tags/storyboard/"},{"name":"Launch","slug":"Launch","permalink":"http://yoursite.com/tags/Launch/"}]},{"title":"Android6.0带来权限的改变","slug":"2015-12-28-Android6.0带来权限的改变","date":"2015-12-28T06:51:33.000Z","updated":"2016-04-18T08:24:36.000Z","comments":true,"path":"2015/12/28/2015-12-28-Android6.0带来权限的改变/","link":"","permalink":"http://yoursite.com/2015/12/28/2015-12-28-Android6.0带来权限的改变/","excerpt":"一直觉得苹果对用户的隐私做得不错，值得安卓借鉴的，苹果对隐私权限的控制，在于当我们涉及用到这条隐私权限所对应的功能时，弹框让我们是否允许这条权限，多好的选择，我们用到才允许隐私权限，然而安卓就硬伤了，安装时候通通申请一篇,如果想安装成功还要全部允许啊。累。坑。！现在随着Android6.0横空出世，带来改变，也让这方面向ios靠近了，这次在原有AndroidManifest中声明的权限中，新增了运行时权限检测，当然这些运动时权限也需要在manifest中声明，不然在检测没有声明的权限，程序会崩溃！","text":"一直觉得苹果对用户的隐私做得不错，值得安卓借鉴的，苹果对隐私权限的控制，在于当我们涉及用到这条隐私权限所对应的功能时，弹框让我们是否允许这条权限，多好的选择，我们用到才允许隐私权限，然而安卓就硬伤了，安装时候通通申请一篇,如果想安装成功还要全部允许啊。累。坑。！现在随着Android6.0横空出世，带来改变，也让这方面向ios靠近了，这次在原有AndroidManifest中声明的权限中，新增了运行时权限检测，当然这些运动时权限也需要在manifest中声明，不然在检测没有声明的权限，程序会崩溃！ 运行时权限： 检测 12345if (ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123;//申请WRITE_EXTERNAL_STORAGE权限&#125;else&#123;&#125; 申请 12ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, WRITE_EXTERNAL_STORAGE_REQUEST_CODE); //参数1上下文，参数2需要申请的权限的字符串数组 参数3回调Code//在Fragment中申请权限，不要使用ActivityCompat.requestPermissions,//直接使用Fragment的requestPermissions方法，否则会回调到Activity的onRequestPermissionsResult 回调 1234567891011121314@Overridepublic void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) &#123; case WRITE_EXTERNAL_STORAGE_REQUEST_CODE: &#123; if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; //允许后处理逻辑 &#125; else &#123; //拒绝后处理逻辑 &#125; break; &#125; &#125;&#125; 应用在使用权限被拒接后再次申请，给出合理解释 12if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.WRITE_EXTERNAL_STORAGE))&#123;&#125; 这边还有涉及到权限组，意思就是当你允许权限组里面任何一个权限申请，之后如果用户有涉及到权限组的另外运行权限时候，系统就会默认该权限组所有权限都可以运行通过，不必再申请了！ 目前已有一些很好开发者做了封装 PermissionGen调用简单，注解回调 Grant简化运行时权限的处理，比较灵活","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"6.0","slug":"6-0","permalink":"http://yoursite.com/tags/6-0/"},{"name":"权限","slug":"权限","permalink":"http://yoursite.com/tags/权限/"}]},{"title":"View中的TouchEvent分析","slug":"2015-10-15-View中的TouchEvent分析","date":"2015-10-15T06:26:32.000Z","updated":"2016-04-18T06:29:44.000Z","comments":true,"path":"2015/10/15/2015-10-15-View中的TouchEvent分析/","link":"","permalink":"http://yoursite.com/2015/10/15/2015-10-15-View中的TouchEvent分析/","excerpt":"开发过程中，我们经常遇到很多View的嵌套使用，但有些View中我们需要不处理它的Touch事件或者处理、拦截事件，这该怎么处理，View中一般包含有三种Touch事件的方法： 事件分发 1public boolean dispatchTouchEvent(MotionEvent ev) 事件拦截 1public boolean onInterceptTouchEvent(MotionEvent ev) 事件响应 1public boolean onTouchEvent(MotionEvent ev)","text":"开发过程中，我们经常遇到很多View的嵌套使用，但有些View中我们需要不处理它的Touch事件或者处理、拦截事件，这该怎么处理，View中一般包含有三种Touch事件的方法： 事件分发 1public boolean dispatchTouchEvent(MotionEvent ev) 事件拦截 1public boolean onInterceptTouchEvent(MotionEvent ev) 事件响应 1public boolean onTouchEvent(MotionEvent ev) view在不通子类中，不是所有子类都包含这三种方法，子类可以分成： ViewGroup子类（容器）LinearLayout、RelativeLayout、ListView等 dispatchTouchEvent() onInterceptTouchEvent() onTouchEvent() 非ViewGroup子类（控件）TextView、Button等 dispatchTouchEvent() onTouchEvent() Activity类 Activity dispatchTouchEvent() onTouchEvent() 传递过程 当TouchEvent发生时，首先Activity将TouchEvent传递给最顶层的View，TouchEvent最先到达最顶层view的dispatchTouchEvent，然后由dispatchTouchEvent方法进行分发： 如果dispatchTouchEvent返回true，则交给这个view的onTouchEvent处理。 如果dispatchTouchEvent返回false，则交给这个view的interceptTouchEvent方法来决定是否要拦截这个事件。 如果interceptTouchEvent返回true，也就是拦截掉了，则交给它的onTouchEvent来处理。 如果interceptTouchEvent返回false，那么就传递给子view，由子view的dispatchTouchEvent再来开始这个事件的分发。 如果事件传递到某一层的子view的onTouchEvent上了，这个方法返回了false，那么这个事件会从这个view往上传递，都是onTouchEvent来接收。 如果传递到最上面的onTouchEvent也返回false的话，这个事件就会“消失”，而且接收不到下一次事件。 参考资料：Android 编程下 Touch 事件的分发和消费机制","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"},{"name":"TouchEvent","slug":"TouchEvent","permalink":"http://yoursite.com/tags/TouchEvent/"}]},{"title":"Android取消EditText焦点","slug":"2015-10-09-Android取消EditText焦点","date":"2015-10-09T11:20:09.000Z","updated":"2016-04-18T02:18:08.000Z","comments":true,"path":"2015/10/09/2015-10-09-Android取消EditText焦点/","link":"","permalink":"http://yoursite.com/2015/10/09/2015-10-09-Android取消EditText焦点/","excerpt":"","text":"开发过程中，我们有时候需要一进到这个页面，不要给EditText有默认焦点，那就要手动去掉编辑框的焦点。 解决办法： 在其父控件下，添加如下的属性，就可以了12android:focusable=&quot;true&quot; android:focusableInTouchMode=&quot;true&quot; eg：12345678910&lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; android:focusable=&quot;true&quot; android:focusableInTouchMode=&quot;true&quot;&gt; &lt;EditText android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; /&gt;&lt;/LinearLayout&gt;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"EditText","slug":"EditText","permalink":"http://yoursite.com/tags/EditText/"},{"name":"焦点","slug":"焦点","permalink":"http://yoursite.com/tags/焦点/"}]},{"title":"实现应用点击两次退出","slug":"2015-08-03-实现应用点击两次退出","date":"2015-08-03T09:33:33.000Z","updated":"2016-04-19T08:35:54.000Z","comments":true,"path":"2015/08/03/2015-08-03-实现应用点击两次退出/","link":"","permalink":"http://yoursite.com/2015/08/03/2015-08-03-实现应用点击两次退出/","excerpt":"","text":"现在很多应用，再退出的时候都做了简洁的处理，比如连续点击两次就退出应用，这种效果简洁、简单！下面就用比较简单的两种方法来实现。这边也总结下System.exit(0)、android.os.Process.killProcess(android.os.Process.myPid())这两种退出，如果有activity存在，没有退出的话，应用会退出后重新进入，这个问题得知：我们要统一管理activity，不然不能完全退出应用！ 一种方法：123456789private static long firstTime;private void quitApp() &#123; if (firstTime + 2000 &gt; System.currentTimeMillis()) &#123; System.exit(0); &#125; else &#123; toast(&quot;再按一次退出程序&quot;); &#125; firstTime = System.currentTimeMillis();&#125; 另外一种：12345678Toast mToast = Toast.makeText(getApplicationContext(), &quot;再按一次退出程序&quot;, 0);private void quitApp() &#123; if(null == mToast.getView().getParent())&#123; mToast.show(); &#125;else&#123; System.exit(0); &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"退出","slug":"退出","permalink":"http://yoursite.com/tags/退出/"}]},{"title":"Android状态栏中多个通知冲突的问题","slug":"2015-07-03-Android状态栏中多个通知冲突的问题","date":"2015-07-03T14:00:15.000Z","updated":"2016-04-18T02:04:34.000Z","comments":true,"path":"2015/07/03/2015-07-03-Android状态栏中多个通知冲突的问题/","link":"","permalink":"http://yoursite.com/2015/07/03/2015-07-03-Android状态栏中多个通知冲突的问题/","excerpt":"自己做推送的时候，发现每次都指向同一个通知，而且是第一个通知，去网上看下问题，原来是PendingIntent的通知id我们固定写成一个常量了，怪不得每次收到都是这个通知呢？","text":"自己做推送的时候，发现每次都指向同一个通知，而且是第一个通知，去网上看下问题，原来是PendingIntent的通知id我们固定写成一个常量了，怪不得每次收到都是这个通知呢？ 问题分析：如果用相同的通知id, 该怎么告诉处理通知的活动，每个通知的内容呢？PendingIntent pendingIntent = PendingIntent.getActivity(this, 0,intent, PendingIntent.FLAG_UPDATE_CURRENT);最后一个参数可以保证显示的是最新的那个通知如果用不同的通知id, 为什么处理通知的活动得到的Intent总是第一个通知的Intent呢？多个Intent是根据它们的Data属性来区分的,如果Data相同,将认为是同一个Intent 解决方法：PendingIntent.getActivity(Context context, int requestCode,Intent intent, int flags)requestCode 值如果一样，就会出现多个通知都指向一个intent。只要requestCode不一样就可以解决问题了！ ps：之前自己测试用的12345678910111213141516171819202122232425262728293031323334private void pushNotifitation()&#123; String ns = Context.NOTIFICATION_SERVICE; NotificationManager mNotificationManager = (NotificationManager) getSystemService(ns); //定义通知栏展现的内容信息 int icon = R.drawable.icon; CharSequence tickerText = &quot;我的通知栏标题&quot;; long when = System.currentTimeMillis(); Notification notification = new Notification(icon, tickerText, when); notification.flags = Notification.FLAG_AUTO_CANCEL; notification.defaults = Notification.DEFAULT_SOUND; //定义下拉通知栏时要展现的内容信息 CharSequence contentTitle = &quot;标题&quot;+et1.getText().toString(); CharSequence contentText = &quot;我的通知栏展开详细内容&quot;; String content_id = et2.getText().toString(); Intent notificationIntent = new Intent(this,PushActivity.class); String json = &quot;&#123;\\&quot;unique_msg\\&quot;:&#123;\\&quot;push_type\\&quot;:\\&quot;&quot;+et1.getText().toString()+&quot;\\&quot;,\\&quot;content_id\\&quot;:\\&quot;&quot;+content_id+&quot;\\&quot; ,\\&quot;content_name\\&quot;:\\&quot;&quot;+et3.getText().toString()+&quot;\\&quot;,\\&quot;externalId\\&quot;:\\&quot;\\&quot;,\\&quot;imageType\\&quot;:\\&quot;\\&quot;&#125;,\\&quot;wap_url\\&quot;:\\&quot;\\&quot; ,\\&quot;title\\&quot;:\\&quot;小暑节气养生test2\\&quot;,\\&quot;info_id\\&quot;:\\&quot;100244\\&quot;,\\&quot;msg_type\\&quot;:\\&quot;0\\&quot;,\\&quot;notice_type\\&quot;:\\&quot;1\\&quot; ,\\&quot;handle_type\\&quot;:\\&quot;0\\&quot;,\\&quot;info\\&quot;:\\&quot;小暑养生要过“六关”！\\&quot;&#125;&quot;; try &#123; JSONObject jsonObject = new JSONObject(json); notificationIntent.putExtra(&quot;uniqueMsg&quot;,jsonObject.getString(&quot;unique_msg&quot;)); notificationIntent.putExtra(&quot;infoId&quot;,jsonObject.getString(&quot;info_id&quot;)); &#125; catch (JSONException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; PendingIntent contentIntent = PendingIntent.getActivity(this, Integer.parseInt(content_id);, notificationIntent, 0); notification.setLatestEventInfo(PushTestActivity.this, contentTitle, contentText, contentIntent); //用mNotificationManager的notify方法通知用户生成标题栏消息通知 mNotificationManager.cancel(Integer.parseInt(et1.getText().toString().trim())); mNotificationManager.notify(Integer.parseInt(et1.getText().toString().trim()), notification);&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"通知","slug":"通知","permalink":"http://yoursite.com/tags/通知/"},{"name":"冲突","slug":"冲突","permalink":"http://yoursite.com/tags/冲突/"},{"name":"状态栏","slug":"状态栏","permalink":"http://yoursite.com/tags/状态栏/"}]},{"title":"Android实现彩票刮奖","slug":"2015-05-25-Android实现彩票刮奖","date":"2015-05-25T01:55:30.000Z","updated":"2016-04-19T07:00:12.000Z","comments":true,"path":"2015/05/25/2015-05-25-Android实现彩票刮奖/","link":"","permalink":"http://yoursite.com/2015/05/25/2015-05-25-Android实现彩票刮奖/","excerpt":"现实生活中，刮奖几乎没有逃脱我们的视线，沃尔玛入口彩票点、各个市区是不是彩票中心等等，今天就用Android来试下，刮奖的效果吧！刮奖主要是通过画图来实现，这个要结合我上一篇文章Android简单学习画图中setXfermode图形渲染两图相交叉的各种情况来完成。来个截图实现后的截图。","text":"现实生活中，刮奖几乎没有逃脱我们的视线，沃尔玛入口彩票点、各个市区是不是彩票中心等等，今天就用Android来试下，刮奖的效果吧！刮奖主要是通过画图来实现，这个要结合我上一篇文章Android简单学习画图中setXfermode图形渲染两图相交叉的各种情况来完成。来个截图实现后的截图。 步骤： 开发自定义View 123456789101112131415161718192021222324public class JGuaJiangView extends View &#123; public JGuaJiangView(Context context) &#123; this(context, null); &#125; public JGuaJiangView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public JGuaJiangView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; return super.onTouchEvent(event); &#125;&#125; 重写OnDraw和onTouchEvent方法 初始化工作123456789101112131415161718192021222324252627282930313233343536private Paint mTextPaint;private Paint mSrcPaint;private String mContent;private Rect mRect;private Path mPath;private Bitmap mBitmap;private Canvas mCanvas;private void init() &#123; mContent = &quot;壹千万元&quot;; mRect = new Rect(); mTextPaint = new Paint(); mTextPaint.setTextSize(140); mTextPaint.setColor(Color.DKGRAY); mTextPaint.setStyle(Style.FILL); mTextPaint.getTextBounds(mContent, 0, mContent.length(), mRect); mSrcPaint = new Paint(); mSrcPaint.setAntiAlias(true); mSrcPaint.setStyle(Style.STROKE); mSrcPaint.setStrokeWidth(50); mPath = new Path(); mBitmap = Bitmap.createBitmap(800, 400, Config.ARGB_8888); mCanvas = new Canvas(mBitmap);&#125; 这里面主要设置中奖文字的Paint，以及包含文字的矩形，初始化了Src的Paint，新建我们自己的画布 设置Touch触摸效果（挂掉的效果） 1234567891011121314151617181920212223242526272829303132 private int mLastX;private int mLastY;@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; int action = event.getAction(); int x = (int) event.getX(); int y = (int) event.getY(); switch (action) &#123; case MotionEvent.ACTION_DOWN: mLastX = x; mLastY = y; mPath.moveTo(mLastX, mLastY); break; case MotionEvent.ACTION_MOVE: int dx = Math.abs(x-mLastX); int dy = Math.abs(y-mLastY); if(dx &gt; 3 || dy &gt; 3)&#123; mPath.lineTo(x, y); &#125; mLastX = x; mLastY = y; break; case MotionEvent.ACTION_UP: break; default: break; &#125; invalidate(); return true;&#125; 最后onDraw 12345678910@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawText(mContent, getWidth()/2-mRect.width()/2, getHeight()/2+mRect.height()/2, mTextPaint); mCanvas.drawColor(Color.parseColor(&quot;#c0c0c0&quot;)); mSrcPaint.setXfermode(new PorterDuffXfermode(Mode.DST_OUT)); mCanvas.drawPath(mPath, mSrcPaint); canvas.drawBitmap(mBitmap, 0, 0, null); &#125; 布局上添加下这个自定义view就可以了 123&lt;com.soubw.jguajiang.JGuaJiangView android:layout_width=&quot;200dp&quot; android:layout_height=&quot;100dp&quot;/&gt; 其实这个最简单的，还可以增加其他效果，比如我挂了面积多大的时候就清除所有的挂图了，也可以增加图片等效果！","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"画图","slug":"画图","permalink":"http://yoursite.com/tags/画图/"},{"name":"Xfermode","slug":"Xfermode","permalink":"http://yoursite.com/tags/Xfermode/"}]},{"title":"Android简单学习画图中setXfermode图形渲染两图相交叉的各种情况","slug":"2015-05-23-Android简单学习画图中setXfermode图形渲染两图相交叉的各种情况","date":"2015-05-23T13:00:09.000Z","updated":"2016-04-19T02:38:26.000Z","comments":true,"path":"2015/05/23/2015-05-23-Android简单学习画图中setXfermode图形渲染两图相交叉的各种情况/","link":"","permalink":"http://yoursite.com/2015/05/23/2015-05-23-Android简单学习画图中setXfermode图形渲染两图相交叉的各种情况/","excerpt":"我们从google官方提供的sdk-&gt;samples-&gt;apiDemos获得Graphics的Xfermode截图，如图：我们通过设置不同的模式可以得到不同的结果！上图先做个说明，为下文准备，图片有16个小格，每个都是一种模式，这边要讲不是数格子，这边想说明是每个各自其实都画出了两个不同的图形，先是圆形Dst（目标图），后是矩形Src（源图），通过两种图片不通模式产生的效果。","text":"我们从google官方提供的sdk-&gt;samples-&gt;apiDemos获得Graphics的Xfermode截图，如图：我们通过设置不同的模式可以得到不同的结果！上图先做个说明，为下文准备，图片有16个小格，每个都是一种模式，这边要讲不是数格子，这边想说明是每个各自其实都画出了两个不同的图形，先是圆形Dst（目标图），后是矩形Src（源图），通过两种图片不通模式产生的效果。 Xfermode各种模式怎么操作步骤： 首先先画出目标图。eg: 123Paint mPaint = new Paint();Bitmap dst = BitmapFactory.decodeResource(getResources(), R.drawable.dst);mCanvas.drawBitmap(dst, 0, 0, mPaint); 其次再设置模式。eg: 1mPaint.setXfermode(new PorterDuffXfermode(Mode.DST_OUT));//图中第二排最后一个效果 最后画出源图。eg: 12Bitmap src = BitmapFactory.decodeResource(getResources(), R.drawable.src);mCanvas.drawBitmap(src, 0, 0, mPaint); 通过不同的模式，就可以达到我们预期想要的效果了！","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"画图","slug":"画图","permalink":"http://yoursite.com/tags/画图/"},{"name":"Xfermode","slug":"Xfermode","permalink":"http://yoursite.com/tags/Xfermode/"},{"name":"Paint","slug":"Paint","permalink":"http://yoursite.com/tags/Paint/"}]},{"title":"Android:exported","slug":"2015-04-08-Android exported","date":"2015-04-08T07:49:21.000Z","updated":"2016-04-19T02:00:32.000Z","comments":true,"path":"2015/04/08/2015-04-08-Android exported/","link":"","permalink":"http://yoursite.com/2015/04/08/2015-04-08-Android exported/","excerpt":"","text":"android:exported 是Android中的四大组件 Activity，Service，Provider，Receiver 四大组件中都会有的一个属性 android:exported的默认值由来决定的，有的话，默认值就是true，没有的话默认值就是false；如果和android:exported两者都有的话，就以android:exported为准。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"exported","slug":"exported","permalink":"http://yoursite.com/tags/exported/"}]},{"title":"Android数据存储路径","slug":"2015-02-27-Android数据存储路径","date":"2015-02-27T02:31:45.000Z","updated":"2016-04-17T17:21:56.000Z","comments":true,"path":"2015/02/27/2015-02-27-Android数据存储路径/","link":"","permalink":"http://yoursite.com/2015/02/27/2015-02-27-Android数据存储路径/","excerpt":"","text":"sd卡路径、包名下缓存路径123456File dateDir = Environment.getDataDirectory();dateDir.getAbsolutePath(); /dataEnvironment.getDataDirectory().getAbsolutePath(); /mnt/sdcardcontext.getExternalFilesDir(null); /mnt/sdcard/Android/data/com.example.client/filescontext.getFilesDir().getAbsolutePath(); /data/data/com.example.client/filescontext.getCacheDir().getAbsolutePath(); /data/data/com.example.client/cache 1.使用Environment.getExternalStorageDirectory可以得到系统的sdcard路径，这个一般在各个手机上都是一样的。2.使用context.getExternalFilesDir可以得到系统为程序在sdcard上分配的存储路径，放在这里卸载程序时目录也会被删除;3.使用context.getFileDir可以获得程序的data目录的files子目录，如果有小文件，sdcard又不存在时可以选择放这里。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"存储","slug":"存储","permalink":"http://yoursite.com/tags/存储/"}]},{"title":"Android打开相册选择图片(兼容4.4以上)","slug":"2015-02-15-Android打开相册选择图片(兼容4.4以上)","date":"2015-02-15T08:12:57.000Z","updated":"2016-04-18T01:38:58.000Z","comments":true,"path":"2015/02/15/2015-02-15-Android打开相册选择图片(兼容4.4以上)/","link":"","permalink":"http://yoursite.com/2015/02/15/2015-02-15-Android打开相册选择图片(兼容4.4以上)/","excerpt":"&#160;&#160;&#160;&#160;android系统的升级，为毛要修改api，坑啊坑啊！！ 一种方法 1234直接设置打开相册的action，intent.setAction(Intent.ACTION_PICK);intent.setData(android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI);后面的onActivityResult里面就可以不区分4.4版本就可以获取到路径。","text":"&#160;&#160;&#160;&#160;android系统的升级，为毛要修改api，坑啊坑啊！！ 一种方法 1234直接设置打开相册的action，intent.setAction(Intent.ACTION_PICK);intent.setData(android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI);后面的onActivityResult里面就可以不区分4.4版本就可以获取到路径。 另一种 123456789101112131415161718192021222324252627在android中选择图片的时候，打开相册选择图片（根据是否4.4设置不同action）， if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.KITKAT) &#123; intent.setAction(Intent.ACTION_OPEN_DOCUMENT); &#125; else &#123; intent.setAction(Intent.ACTION_GET_CONTENT); &#125;；在onActivityResult里面返回的Uri uri = data.getData();如果是android4.4 uri格式为content://com.android.providers.media.documents/document/image:3952,4.4以下格式为content://media/external/images/media/3951，要获取图片的存储路径需要：if(android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.KITKAT)&#123; String wholeID = DocumentsContract.getDocumentId(contentUri); String id = wholeID.split(:)[1]; String[] column = &#123; MediaStore.Images.Media.DATA &#125;; String sel = MediaStore.Images.Media._ID + =?; Cursor cursor = context.getContentResolver().query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, column, sel, new String[] &#123; id &#125;, null); int columnIndex = cursor.getColumnIndex(column[0]); if (cursor.moveToFirst()) &#123; filePath = cursor.getString(columnIndex); &#125; cursor.close();&#125;else&#123; String[] projection = &#123; MediaStore.Images.Media.DATA &#125;; Cursor cursor = context.getContentResolver().query(contentUri, projection, null, null, null); int column_index = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA); cursor.moveToFirst(); filePath = cursor.getString(column_index);&#125;。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"相册","slug":"相册","permalink":"http://yoursite.com/tags/相册/"},{"name":"疑难杂症","slug":"疑难杂症","permalink":"http://yoursite.com/tags/疑难杂症/"},{"name":"4.4","slug":"4-4","permalink":"http://yoursite.com/tags/4-4/"}]},{"title":"设计模式之单例模式多种实现","slug":"2014-11-08-设计模式之单例模式多种实现","date":"2014-11-08T03:56:07.000Z","updated":"2016-04-19T09:15:24.000Z","comments":true,"path":"2014/11/08/2014-11-08-设计模式之单例模式多种实现/","link":"","permalink":"http://yoursite.com/2014/11/08/2014-11-08-设计模式之单例模式多种实现/","excerpt":"","text":"单例模式是二十三种设计模式的使用最广的一种了，对于单例模式的实现，我这边总结下总共有四种之多，这四种都是线程安全。单例模式是确保某一个类只有一个实例，并且我们在应用过程中任何地方都是使用这个实例化的实例。避免某个类产生多个对象而消耗过多的资源，确保某个类在程序中只有一个实例。比如我们使用的图片加载器ImageLoader或者一些工具类。往往单例创建的对象，耗费的资源都比较多，所以在初始化单例对象的时候就显得尤为重要。 类加载后也同时也创建实例化对象 1234567public class Singleton &#123; private static Singleton instance = new Singleton(); public static Singleton getInstance() &#123; return instance; &#125;&#125; 双重判断加锁机制 1234567891011121314public class Singleton &#123; private static Singleton instance; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; Java的枚举 1234567891011public enum Singleton &#123; INSTANCE; private Singleton()&#123; &#125; public void useSingleton() &#123; &#125;&#125;//使用这样调用 Singleton.INSTANCE.useSingleton(); 静态内部类实现模式 123456789public class Singleton &#123; private static final class InnerInstance &#123; private static Singleton instance = new Singleton(); &#125; public static Singleton getInstance() &#123; return InnerInstance.instance; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"单例","slug":"单例","permalink":"http://yoursite.com/tags/单例/"}]},{"title":"Java 对象引用的个人分析","slug":"2014-08-03-Java 对象引用的个人分析","date":"2014-08-03T00:55:14.000Z","updated":"2016-04-25T01:50:06.000Z","comments":true,"path":"2014/08/03/2014-08-03-Java 对象引用的个人分析/","link":"","permalink":"http://yoursite.com/2014/08/03/2014-08-03-Java 对象引用的个人分析/","excerpt":"分析之前，先来到编程题：12345678910111213141516171819202122232425public class Test&#123; String str = &quot;WX_JIN&quot;; char ch[] = &#123;&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;&#125;; private void switchValue(String str, char ch[], A a)&#123; str = &quot;Hello&quot;; ch[0] = &apos;b&apos;; a.name = &quot;BBBBB&quot;; &#125; public static class A&#123; String name; &#125; public static void main(String ags[])&#123; A a = new A(); a.name = &quot;AAAAA&quot;; Test test = new Test(); test.switchValue(test.str, test.ch, a); System.out.print(test.str+&quot; and &quot;); System.out.print(test.ch); System.out.print(&quot; and &quot;+a.name); &#125;&#125; 输入值是什么呢？答案是：WX_JIN and bbcd and BBBBB 为什么呢？其实只要记得在Java里没有引用传递，只有值传递","text":"分析之前，先来到编程题：12345678910111213141516171819202122232425public class Test&#123; String str = &quot;WX_JIN&quot;; char ch[] = &#123;&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;&#125;; private void switchValue(String str, char ch[], A a)&#123; str = &quot;Hello&quot;; ch[0] = &apos;b&apos;; a.name = &quot;BBBBB&quot;; &#125; public static class A&#123; String name; &#125; public static void main(String ags[])&#123; A a = new A(); a.name = &quot;AAAAA&quot;; Test test = new Test(); test.switchValue(test.str, test.ch, a); System.out.print(test.str+&quot; and &quot;); System.out.print(test.ch); System.out.print(&quot; and &quot;+a.name); &#125;&#125; 输入值是什么呢？答案是：WX_JIN and bbcd and BBBBB 为什么呢？其实只要记得在Java里没有引用传递，只有值传递 分析：这边我修正下代码：swithValue方法的局部变量我是故意跟外面的变量一样，这边有点误导，其实这边体现变量的作用域，现在我把方法重新改下，会清晰很多：12345private void switchValue(String str1, char ch1[], A a1)&#123; str1 = &quot;Hello&quot;; ch1[0] = &apos;b&apos;; a1.name = &quot;BBBBB&quot;;&#125; 是不是清晰很多了，现在我们重新理解下调用swithValue方法的过程，其实相当于：123String str1 = test.str;char ch1[] = test.chA a1 = a; 这边的等号，是把test.str存的值（值为对象的地址）赋值给了str1，所以str1的值和test.str的值是一样的都是对象的地址，他们指向同一个对象。同理ch1和a1也一样。 先分析下String，把String这行代码分解下：1String str = &quot;WX_JIN&quot;; String是一个类，str是一个引用，str这个引用指向哪里呢，str指向一个存有“WX_JIN”的对象，所以str的值存的“WX_JIN”对象的地址，那么这“WX_JIN”对象的值就是WX_JIN了。现在我以个人理解把上面这句话转变下：String理解为一种类型的气球，str理解为一条绳子，绳子连接哪个气球呢，绳子系一个写有“WX_JIN”的字样的气球上，所有这里的绳子结就是绳子和气球的连接的枢纽（我把这个绳子结理解成对象的地址），那么这个“WX_JIN”对象就可以理解成写着WX_JIN字样的气球。大致比较啰嗦，但希望能看得懂！当我们调用switchValue方法时：我们理解成：你新拿出一条绳子str1，也向test.str指向的这个气球打了个结，系住。这时只是调用方法时的赋值，接着往下执行代码str1 = “Hello”，这句可以理解成我重新买了个写着“Hello”的气球，把之前系在写有“WX_JIN”的字样的气球解开，系在了str1这条绳子上。但我们最终要输出的str这条绳子系的气球上面的字。输出当然是WX_JIN 有了String基础现在来分析下char，分解下：1char ch[] = &#123;&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;&#125;; 这边要理解成char是一种类型的气球，ch[]是一条绳子，绳子连接哪个气球呢，绳子系写着有“a”、有“b”、有“c”、有“d”的气球上，所有这里的绳子结就是绳子和气球的连接的枢纽（我把这个绳子结理解成对象的地址），那么这个{‘a’, ‘b’, ‘c’, ‘d’}对象就可以理解成写着有“a”、有“b”、有“c”、有“d”的气球。跟上面一样，ch1[]是新的一条绳子，也系在写着有“a”、有“b”、有“c”、有“d”的气球上，但之后的ch1[0]这个可不一样，这边已指向对象的地址的值了，可以理解成，现在我的绳子指向的是气球上第0位那个字“a”,具体化了;那么我在现在ch1[0]既然为“a”,我把“a”擦掉改写成“b”，那么气球上的字当然变了。输出当然是bbcd 最后来看下对象A，分解下：12A a = new A();a.name = &quot;AAAAA&quot;; 这边要理解成A是一种类型的气球，a是一条绳子，对象是在气球某个区域（属性name当成气球的某个角落）写着有“AAAAA”的气球。跟上面一样，a1是新的一条绳子也系在写着有“AAAAA”的气球上，但之后的a1.name这个可不一样，这边已指向对象的地址的值了，可以理解成，现在我的绳子指向的是气球上name这区域的字“AAAAA”;那么我在现在a1.name既然写着“AAAAA”,我把“AAAAA”擦掉改写成“BBBBB”，那么气球上的字当然变了。输出当然是BBBBB 加深理解：B b;b为一条绳子，没有系在哪里，所以他没有绳子结，指向为null;B b1 = new B();b1也为一条绳子，他系在B对象这个气球上，系的这个结就是对象的地址（理解：b1存的值就是气球的特性，我们才知道系哪个气球）。一条绳子只能系一个气球，但一个气球可以有很多不通绳子系着。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"对象","slug":"对象","permalink":"http://yoursite.com/tags/对象/"},{"name":"引用","slug":"引用","permalink":"http://yoursite.com/tags/引用/"}]},{"title":"Java Pattern和Matcher对字符串进行正则匹配","slug":"2014-07-21-Java Pattern和Matcher对字符串进行正则匹配","date":"2014-07-21T02:05:24.000Z","updated":"2016-04-25T01:50:24.000Z","comments":true,"path":"2014/07/21/2014-07-21-Java Pattern和Matcher对字符串进行正则匹配/","link":"","permalink":"http://yoursite.com/2014/07/21/2014-07-21-Java Pattern和Matcher对字符串进行正则匹配/","excerpt":"","text":"&#160;&#160;&#160;&#160;之前做链接拉起客户端，需要对链接直接拆分，这里面有有涉及到这块知识，自己去搜索下这块的资料，稍加自己的理解，记录下。java.util.regex是一个用正则表达式所订制的模式来对字符串进行匹配工作的类库包，它包括两个类：Pattern和Matcher。 Pattern： static Pattern compile(String regex) 将给定的正则表达式编译并赋予给Pattern类，生成一个Pattern对象 eg: 123456789101112//生成一个Pattern,同时编译一个正则表达式 Pattern p = Pattern.compile(&quot;[/]+&quot;); //用Pattern的split()方法把字符串按&quot;/&quot;分割 String[] result = p.split( &quot;Kevin has seen《LEON》seveal times，because it is a good film。/ 凯文已经看过《这个杀手不太冷》几次了，因为它是一部好电影。/名词：凯文。&quot;); for (int i=0; i&lt;result.length; i++) System.out.println(result[i]); 输出结果为：Kevin has seen《LEON》seveal times，because it is a good film。凯文已经看过《这个杀手不太冷》几次了，因为它是一部好电影。名词：凯文。&lt;!-- more --&gt; static Pattern compile(String regex, int flags) 在上面的基础可以增加flag参数的指定，可选的flag参数包括：CASE_INSENSITIVE（这个标志能让表达式忽略大小写进行匹配。要想对Unicode字符进行大小不明感的匹 配，只要将UNICODE_CASE与这个标志合起来就行了）COMMENTS（匹配时会忽略(正则表达式里的)空格字符(不是指表达式里的”\\s”，而是指表达式里的空格，tab，回车之类)）MULTILINE（’^’和’$’分别匹配一行的开始和结束。此外，’^’仍然匹配字符串的开始，’$’也匹配字符串的结束）DOTALL（表达式’.’可以匹配任意字符，包括表示一行的结束符。默认情况下，表达式’.’不匹配行的结束符）UNIX_LINES（只有’\\n’才被认作一行的中止，并且与’.’，’^’，以及’$’进行匹配）UNICODE CASE（如果你还启用了CASE_INSENSITIVE标志，那么它会对Unicode字符进行大小写不明感的匹配。默认情况下，大小写不敏感的匹配只适用于US-ASCII字符集）CANON_EQ（当且仅当两个字符的”正规分解(canonical decomposition)”都完全相同的情况下，才认定匹配） Matcher matcher(CharSequence input) 生成一个给定命名的Matcher对象 static boolean matches(String regex, CharSequence input) 编译给定的正则表达式并且对输入的字串以该正则表达式为模开展匹配,该方法适合于该正则表达式只会使用一次的情况，也就是只进行一次匹配工作，因为这种情况下并不需要生成一个Matcher实例。 String pattern() 返回该Patter对象所编译的正则表达式。 String[] split(CharSequence input) 将目标字符串按照Pattern里所包含的正则表达式为模进行分割。 String[] split(CharSequence input, int limit) 作用同上，增加参数limit目的在于要指定分割的段数，如将limi设为2，那么目标字符串将根据正则表达式分为割为两段。 Matcher Matcher appendReplacement(StringBuffer sb, String replacement) 将当前匹配子串替换为指定字符串，并且将替换后的子串以及其之前到上次匹配子串之后的字符串段添加到一个StringBuffer对象里。StringBuffer appendTail(StringBuffer sb)将最后一次匹配工作后剩余的字符串添加到一个StringBuffer对象里。 int end() 返回当前匹配的子串的最后一个字符在原目标字符串中的索引位置 。 int end(int group) 返回与匹配模式里指定的组相匹配的子串最后一个字符的位置。 boolean find() 尝试在目标字符串里查找下一个匹配子串。 boolean find(int start) 重设Matcher对象，并且尝试在目标字符串里从指定的位置开始查找下一个匹配的子串。 String group() 返回当前查找而获得的与组匹配的所有子串内容 String group(int group) 返回当前查找而获得的与指定的组匹配的子串内容 int groupCount() 返回当前查找所获得的匹配组的数量。 boolean lookingAt() 检测目标字符串是否以匹配的子串起始。 boolean matches() 尝试对整个目标字符展开匹配检测，也就是只有整个目标字符串完全匹配时才返回真值。 Pattern pattern() 返回该Matcher对象的现有匹配模式，也就是对应的Pattern 对象。 String replaceAll(String replacement) 将目标字符串里与既有模式相匹配的子串全部替换为指定的字符串。 String replaceFirst(String replacement) 将目标字符串里第一个与既有模式相匹配的子串替换为指定的字符串。 Matcher reset() 重设该Matcher对象。 Matcher reset(CharSequence input) 重设该Matcher对象并且指定一个新的目标字符串。 int start() 返回当前查找所获子串的开始字符在原目标字符串中的位置。 int start(int group) 返回当前查找所获得的和指定组匹配的子串的第一个字符在原目标字符串中的位置。 正则表达式规则： 字符 1234567891011121314 x 字符 x\\\\ 反斜线字符\\0n 八进制值的字符0n (0 &lt;= n &lt;= 7)\\0nn 八进制值的字符 0nn (0 &lt;= n &lt;= 7)\\0mnn 八进制值的字符0mnn 0mnn (0 &lt;= m &lt;= 3, 0 &lt;= n &lt;= 7)\\xhh 十六进制值的字符0xhh\\uhhhh 十六进制值的字符0xhhhh\\t 制表符(&apos;\\u0009&apos;)\\n 换行符 (&apos;\\u000A&apos;)\\r 回车符 (&apos;\\u000D&apos;)\\f 换页符 (&apos;\\u000C&apos;)\\a 响铃符 (&apos;\\u0007&apos;)\\e 转义符 (&apos;\\u001B&apos;)\\cx T对应于x的控制字符X *字符类 123456789[abc] a, b, or c (简单类)[^abc] 除了a、b或c之外的任意 字符（求反）[a-zA-Z] a到z或A到Z ，包含（范围)[a-z-[bc]] a到z，除了b和c ： [ad-z]（减去 [a-z-[m-p]] a到z，除了m到 p： [a-lq-z][a-z-[^def]] d, e, 或 f 备注：方括号的正则表达式“t[aeio]n”只匹配“tan”、“Ten”、“tin”和“ton”，只能匹配单个字符。圆括号，因为方括号只允许匹配单个字符；故匹配多个字符时使用圆括号“()”。比如使用“t(a|e|i|o|oo)n”正则表达式，就必须用圆括号。 预定义的字符类 1234567. 任意字符（也许能与行终止符匹配，也许不能） 备注：句点符号代表任意一个字符。比如：表达式就是“t.n”，它匹配“tan”、“ten”、“tin”和“ton”，还匹配“t#n”、“tpn”甚至“t n”。\\d 数字: [0-9]\\D 非数字: [^0-9]\\s 空格符: [ \\t\\n\\x0B\\f\\r]\\S 非空格符: [^\\s]\\w 单词字符: [a-zA-Z_0-9]\\W 非单词字符: [^\\w] 表达次数的符号 123456符号 次数* 0次或者多次+ 1次或者多次? 0次或者1次&#123;n&#125; 恰好n次&#123;n,m&#125; 从n次到m次 自己的例子 1234567891011121314private static String[][] getContent(String content)&#123;if (content == null) return null;Pattern p = Pattern.compile(&quot;\\r\\n&quot;);String[] s = p.split(content);int count = s.length;Pattern p2 = Pattern.compile(&quot;;&quot;);String[][] detailContent = new String[count][];for (int i = 0; i &lt; count; i++)&#123; String[] s2 = p2.split(s[i]); detailContent[i] = s2;&#125;return detailContent;&#125; 参考资料 JAVA正则表达式 Pattern和Matcher","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Pattern","slug":"Pattern","permalink":"http://yoursite.com/tags/Pattern/"},{"name":"Matcher","slug":"Matcher","permalink":"http://yoursite.com/tags/Matcher/"}]},{"title":"Android 设置自定义协议，短信链接拉起客户端","slug":"2014-07-19-Android 设置自定义协议，短信链接拉起客户端","date":"2014-07-19T03:07:24.000Z","updated":"2016-04-18T01:35:20.000Z","comments":true,"path":"2014/07/19/2014-07-19-Android 设置自定义协议，短信链接拉起客户端/","link":"","permalink":"http://yoursite.com/2014/07/19/2014-07-19-Android 设置自定义协议，短信链接拉起客户端/","excerpt":"&#160;&#160;&#160;&#160;根据产品那边需求，需要从短信下发链接拉起客户端，如果手机有安装客户端拉起，没有就就跳转到下载界面。这里涉及到链接的拉起，google搜索下，得到答案，这边记录下！ 步骤： 设置scheme这边就是要设置协议的名称，比如我们经常使用的http、https协议 设置host这边要设置是域名,比如百度域名：baidu.com","text":"&#160;&#160;&#160;&#160;根据产品那边需求，需要从短信下发链接拉起客户端，如果手机有安装客户端拉起，没有就就跳转到下载界面。这里涉及到链接的拉起，google搜索下，得到答案，这边记录下！ 步骤： 设置scheme这边就是要设置协议的名称，比如我们经常使用的http、https协议 设置host这边要设置是域名,比如百度域名：baidu.com 我们需要在在androidmanifest.xml中选择一个Activity或者service的昨晚拉起的载体。eg:123456789&lt;!-- 链接进入控制页面 --&gt; &lt;activity android:name=&quot;.LinkEnterActivity&quot; android:screenOrientation=&quot;portrait&quot; &gt; &lt;intent-filter&gt; &lt;data android:scheme=&quot;http&quot; /&gt; &lt;data android:host=&quot;dm.10086.cn&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"协议","slug":"协议","permalink":"http://yoursite.com/tags/协议/"}]},{"title":"使用yilia主题","slug":"2014-06-25-使用yilia主题","date":"2014-06-25T01:27:17.000Z","updated":"2016-04-20T07:53:38.000Z","comments":true,"path":"2014/06/25/2014-06-25-使用yilia主题/","link":"","permalink":"http://yoursite.com/2014/06/25/2014-06-25-使用yilia主题/","excerpt":"&#160;&#160;&#160;&#160;记录下自己使用yilia主题过程中所涉及的一些东东，一分耕耘一分收获，慢慢积累经验、一点一滴记录自己所作所为！安装node、Git以及github，自行google or baidu!","text":"&#160;&#160;&#160;&#160;记录下自己使用yilia主题过程中所涉及的一些东东，一分耕耘一分收获，慢慢积累经验、一点一滴记录自己所作所为！安装node、Git以及github，自行google or baidu! 步骤： 拷贝yilia主题 1$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 配置Hexo主题为yilia 1修改hexo根目录下的 _config.yml ： theme: yilia 注册多说 1获取多说shortname 修改yilia配置信息 12avatar: /img/wxj.png 你的头像url或者文件目录duoshuo: xxx 开启多说评论，值为你上面注册获取的shortname 设置网站小图标在你主题下的\\layout_partial\\head.ejs增加一段代码 1&lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot; href=&quot;&lt;%- config.root %&gt;favicon.ico&quot;&gt; 并且制作下图标ico 放在hexo\\source的目录就可以了！ 加入404网页同样在hexo\\source的目录放入404页面就可以了！我放的是腾讯公益404其他可以按yilia主题贡献者的说明修改！ 执行： clean 1hexo clean generator 1hexo g deploy 1hexo d over!","categories":[{"name":"Github博客","slug":"Github博客","permalink":"http://yoursite.com/categories/Github博客/"}],"tags":[{"name":"yilia主题","slug":"yilia主题","permalink":"http://yoursite.com/tags/yilia主题/"}]}]}